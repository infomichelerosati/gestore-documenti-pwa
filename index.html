<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archivia i tuoi Documenti</title>
    
    <!-- Tailwind CSS per uno stile moderno e responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      // Configura Tailwind per usare la strategia 'class' per il dark mode
      tailwind.config = {
        darkMode: 'class'
      }
    </script>
    
    <!-- Icone Lucide -->
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.378.0/dist/umd/lucide.min.js"></script>

    <!-- Libreria JSZip per gestire file .zip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- Libreria Tesseract.js per OCR client-side -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>

    <!-- Libreria PDF.js per anteprime PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <!-- Font Inter da Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Meta tag per la PWA -->
    <meta name="theme-color" content="#317EFB"/>
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/317EFB/ffffff?text=Docs">
    
    <!-- Manifest della PWA incorporato direttamente (con migliorie) -->
    <link rel="manifest" href='data:application/manifest+json,{
        "name": "Gestore Documenti PWA",
        "short_name": "GestoreDoc",
        "id": "./?v=1",
        "start_url": ".",
        "display": "standalone",
        "orientation": "portrait",
        "background_color": "#f3f4f6",
        "theme_color": "#317EFB",
        "description": "Un semplice gestore di documenti PWA per organizzarli e ricercarli.",
        "icons": [
            { "src": "https://placehold.co/192x192/317EFB/ffffff?text=Docs", "type": "image/png", "sizes": "192x192", "purpose": "any maskable" },
            { "src": "https://placehold.co/512x512/317EFB/ffffff?text=Docs", "type": "image/png", "sizes": "512x512", "purpose": "any maskable" }
        ]
    }'>

    <style>
        html.dark { color-scheme: dark; }
        body { font-family: 'Inter', sans-serif; overflow-x: hidden; }
        .sidebar { transition: transform 0.3s ease-in-out; }
        .sidebar-overlay { transition: opacity 0.3s ease-in-out; }
        .details-content { overflow: hidden; transition: max-height 0.3s ease-out; }
        details[open] .details-content { max-height: 1000px; }
        details .summary-arrow { transition: transform 0.2s; }
        details[open] .summary-arrow { transform: rotate(90deg); }
        .filter-tree ul { padding-left: 1rem; }
        .filter-tree summary, .filter-tree li { cursor: pointer; }
        .filter-tree summary.active > span, .filter-tree li.active > span { font-weight: bold; color: #3b82f6; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        html.dark ::-webkit-scrollbar-track { background: #2d3748; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px;}
        html.dark ::-webkit-scrollbar-thumb { background: #555; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        html.dark ::-webkit-scrollbar-thumb:hover { background: #444; }
        .ocr-loader {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .highlight-suggestion {
            animation: pulse-bg 2s infinite;
        }
        @keyframes pulse-bg {
            0% { background-color: inherit; }
            50% { background-color: rgba(59, 130, 246, 0.1); }
            100% { background-color: inherit; }
        }
        .powered-by {
            position: fixed;
            top: 4px;
            left: 50%;
            font-size: 0.65rem;
            font-weight: 500;
            z-index: 50;
            pointer-events: none;
            animation: color-cycle 18s linear infinite, pulse-light 4s ease-in-out infinite;
            text-shadow: 0 0 3px rgba(0,0,0,0.4);
            background: transparent;
        }
        @keyframes color-cycle {
            0%   { color: #ff8a80; } 16%  { color: #ffcf7d; } 33%  { color: #b9f6ca; } 50%  { color: #84ffff; }
            67%  { color: #8c9eff; } 83%  { color: #f8bbd0; } 100% { color: #ff8a80; }
        }
        @keyframes pulse-light {
            0%, 100% { transform: translateX(-50%) scale(1); opacity: 0.9; }
            50%      { transform: translateX(-50%) scale(1.05); opacity: 1; }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200">
    <div class="powered-by">Powered By Michele Rosati</div>

    <!-- Sidebar a scomparsa per i filtri -->
    <aside id="sidebar" class="sidebar fixed top-0 left-0 w-72 h-full bg-white dark:bg-gray-800 shadow-lg z-30 transform -translate-x-full flex flex-col">
        <div class="p-4 flex-grow overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Filtra Documenti</h2>
                <button id="close-sidebar-btn" class="p-1 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            
            <div class="mb-4 bg-gray-50 dark:bg-gray-700/50 p-3 rounded-lg text-sm space-y-2">
                <h3 class="font-semibold text-gray-800 dark:text-gray-200">Statistiche Archivio</h3>
                <div class="flex justify-between items-center">
                    <span class="text-gray-600 dark:text-gray-400">Documenti totali:</span>
                    <span id="stats-total-docs" class="font-bold">0</span>
                </div>
                <div class="flex justify-between items-center">
                    <span class="text-gray-600 dark:text-gray-400">Spazio occupato:</span>
                    <span id="stats-total-size" class="font-bold">0 MB</span>
                </div>
            </div>

            <button id="reset-filter-btn" class="w-full text-center text-sm mb-4 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 p-2 rounded-md">Mostra tutti</button>
            
            <h3 class="text-lg font-semibold mb-2 mt-4">Categorie</h3>
            <div id="filter-tree" class="filter-tree"></div>

        </div>
        <div class="p-4 border-t border-gray-200 dark:border-gray-700">
            <h2 class="text-lg font-semibold mb-3">Impostazioni</h2>
            <div class="space-y-2">
                <button id="export-data-btn" class="w-full flex items-center gap-2 p-2 rounded-md text-sm text-left bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600">
                    <i data-lucide="download" class="w-4 h-4"></i>
                    <span>Esporta Dati</span>
                </button>
                <button id="import-data-btn" class="w-full flex items-center gap-2 p-2 rounded-md text-sm text-left bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600">
                     <i data-lucide="upload" class="w-4 h-4"></i>
                    <span>Importa Dati</span>
                </button>
                <input type="file" id="import-file-input" class="hidden" accept=".zip">
            </div>
        </div>
    </aside>
    <div id="sidebar-overlay" class="sidebar-overlay fixed inset-0 bg-black bg-opacity-50 z-20 hidden"></div>

    <!-- Contenuto Principale -->
    <div class="container mx-auto max-w-6xl h-screen flex flex-col">
        <div class="flex-shrink-0 bg-gray-100 dark:bg-gray-900 z-10 sticky top-0 pt-4 px-4">
            <header class="flex justify-between items-center mb-6">
                <div class="flex items-center gap-4">
                    <button id="menu-btn" class="p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700">
                        <i data-lucide="menu" class="w-6 h-6"></i>
                    </button>
                    <h1 class="text-3xl font-bold text-blue-600 dark:text-blue-400">Gestore Documenti</h1>
                </div>
                <div class="flex items-center gap-2">
                    <button id="theme-toggle-btn" class="p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700">
                        <i data-lucide="sun" class="w-6 h-6 block dark:hidden"></i>
                        <i data-lucide="moon" class="w-6 h-6 hidden dark:block"></i>
                    </button>
                    <button id="installBtn" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                        Installa App
                    </button>
                </div>
            </header>

            <div class="mb-6 flex flex-col sm:flex-row gap-4">
                <div class="relative flex-grow">
                    <input type="search" id="search-input" placeholder="Cerca in nome, tag, dettagli..." class="w-full p-3 pl-10 text-sm border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none dark:placeholder-gray-400">
                    <div class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                        <i data-lucide="search" class="w-5 h-5 text-gray-400"></i>
                    </div>
                </div>
                <div class="flex items-center gap-2 flex-shrink-0">
                    <select id="sort-select" class="w-full sm:w-auto p-3 text-sm border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                        <option value="date_desc">Più Recenti</option>
                        <option value="date_asc">Meno Recenti</option>
                        <option value="name_asc">Nome (A-Z)</option>
                        <option value="name_desc">Nome (Z-A)</option>
                        <option value="year_desc">Anno (Decrescente)</option>
                        <option value="year_asc">Anno (Crescente)</option>
                    </select>
                    <select id="items-per-page-select" class="w-full sm:w-auto p-3 text-sm border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                        <option value="10">10 per pagina</option>
                        <option value="20">20 per pagina</option>
                        <option value="50">50 per pagina</option>
                        <option value="99999">Mostra tutti</option>
                    </select>
                     <div class="flex rounded-lg shadow-sm bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700">
                        <button id="view-list-btn" class="p-3 text-blue-500 bg-blue-50 dark:bg-gray-700 rounded-l-md" title="Vista a Lista">
                            <i data-lucide="list" class="w-5 h-5"></i>
                        </button>
                        <button id="view-grid-btn" class="p-3 text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700" title="Vista a Griglia">
                            <i data-lucide="layout-grid" class="w-5 h-5"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="scrollable-content" class="flex-grow overflow-y-auto pb-24 px-4">
            <main id="document-list-container"></main>
            
            <div id="pagination-container" class="text-center py-8">
                <button id="load-more-btn" class="hidden bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 font-bold py-2 px-5 rounded-lg">Carica altri</button>
            </div>

            <div id="empty-state" class="hidden text-center py-16">
                <i data-lucide="folder-open" class="mx-auto h-12 w-12 text-gray-400"></i>
                <h3 class="mt-2 text-sm font-semibold text-gray-900 dark:text-gray-100">Nessun documento</h3>
                <p class="mt-1 text-sm text-gray-500">Aggiungi un documento o cambia i filtri di ricerca.</p>
            </div>
        </div>
    </div>

    <button id="add-doc-btn" class="fixed bottom-6 right-6 bg-blue-600 hover:bg-blue-700 text-white p-4 rounded-full shadow-lg transition-transform transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 z-20">
        <i data-lucide="plus" class="w-6 h-6"></i>
    </button>
    
    <div id="doc-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center p-4 z-40">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md p-6 max-h-[90vh] overflow-y-auto">
            <h2 id="modal-title" class="text-2xl font-bold mb-4">Aggiungi Documento</h2>
            <form id="doc-form">
                <input type="hidden" id="doc-id">
                <div class="mb-4">
                    <label for="doc-file" class="block text-sm font-medium mb-1">File Principale</label>
                    <div class="flex items-center gap-2">
                        <input type="file" id="doc-file" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 dark:file:bg-gray-700 file:text-blue-700 dark:file:text-blue-300 hover:file:bg-blue-100 dark:hover:file:bg-gray-600"/>
                        <button type="button" id="ocr-btn" title="Analizza documento con OCR (immagini o PDF)" class="flex-shrink-0 p-2 rounded-full bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed">
                            <i data-lucide="scan-text" class="w-5 h-5"></i>
                        </button>
                    </div>
                    <div id="ocr-status" class="text-xs text-gray-500 mt-1 flex items-center gap-1.5"></div>
                    <div id="current-file-name" class="text-xs text-gray-500 mt-1"></div>
                </div>
                
                <div id="file-preview-container" class="mb-4 hidden">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Anteprima</label>
                    <div id="file-preview" class="mt-1 p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-gray-50 dark:bg-gray-700 max-h-48 overflow-y-auto flex justify-center items-center"></div>
                </div>
                
                <div class="mb-4">
                    <label for="doc-attachments" class="block text-sm font-medium mb-1">Allega altri file</label>
                    <input type="file" id="doc-attachments" multiple class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 dark:file:bg-gray-700 file:text-blue-700 dark:file:text-blue-300 hover:file:bg-blue-100 dark:hover:file:bg-gray-600"/>
                    <div id="attachments-list" class="mt-2 space-y-1 text-sm"></div>
                </div>

                <div class="mb-4"><label for="doc-name" class="block text-sm font-medium mb-1">Nome Visualizzato</label><input type="text" id="doc-name" required class="mt-1 block w-full p-2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm dark:placeholder-gray-400"></div>
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div><label for="doc-year" class="block text-sm font-medium mb-1">Anno</label><input type="number" id="doc-year" placeholder="Es. 2025" required class="mt-1 block w-full p-2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm dark:placeholder-gray-400"></div>
                    <div><label for="doc-category" class="block text-sm font-medium mb-1">Categoria</label><input list="category-suggestions" type="text" id="doc-category" placeholder="Es. Bollette" required class="mt-1 block w-full p-2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm dark:placeholder-gray-400"></div>
                </div>
                <div class="mb-4"><label for="doc-subcategory" class="block text-sm font-medium mb-1">Sottocategoria</label><input list="subcategory-suggestions" type="text" id="doc-subcategory" placeholder="Es. Gas" required class="mt-1 block w-full p-2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm dark:placeholder-gray-400"></div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-1">Tag</label>
                    <div id="selected-tags-container" class="flex flex-wrap gap-2 items-center p-2 rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 min-h-[42px] cursor-text">
                        <input type="text" id="doc-tags-input" placeholder="Aggiungi tag..." class="flex-grow bg-transparent outline-none border-none p-0 text-sm">
                    </div>
                    <input type="hidden" id="doc-tags" name="doc-tags">
                    <div id="available-tags-section" class="mt-2 hidden">
                        <label class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Tag suggeriti per questa categoria:</label>
                        <div id="available-tags-container" class="flex flex-wrap gap-1 text-xs"></div>
                    </div>
                </div>

                <div class="mb-6"><label for="doc-details" class="block text-sm font-medium mb-1">Dettagli</label><textarea id="doc-details" rows="3" placeholder="Aggiungi note qui..." class="mt-1 block w-full p-2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm dark:placeholder-gray-400"></textarea></div>
                <div class="flex justify-end space-x-3">
                    <button type="button" id="cancel-btn" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500 font-bold py-2 px-4 rounded-lg">Annulla</button>
                    <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Salva</button>
                </div>
            </form>
            <datalist id="category-suggestions"></datalist>
            <datalist id="subcategory-suggestions"></datalist>
            <datalist id="tags-suggestions"></datalist>
        </div>
    </div>

    <div id="preview-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex flex-col p-4 z-50">
        <div class="flex-shrink-0 flex justify-between items-center text-white mb-4">
            <h2 id="preview-title" class="text-xl font-bold">Anteprima</h2>
            <div class="flex items-center gap-4">
                <button id="print-btn" title="Stampa"><i data-lucide="printer" class="w-6 h-6"></i></button>
                <button id="download-btn" title="Scarica"><i data-lucide="download" class="w-6 h-6"></i></button>
                <button id="edit-preview-btn" title="Modifica"><i data-lucide="edit-2" class="w-6 h-6"></i></button>
                <button id="delete-preview-btn" title="Elimina"><i data-lucide="trash-2" class="w-6 h-6 text-red-400"></i></button>
                <button id="close-preview-btn" title="Chiudi"><i data-lucide="x" class="w-8 h-8"></i></button>
            </div>
        </div>
        <div id="preview-content" class="flex-grow flex items-center justify-center overflow-auto relative"></div>
        <div id="preview-attachments-bar" class="flex-shrink-0 bg-black bg-opacity-50 p-2 text-white text-center overflow-x-auto whitespace-nowrap hidden"></div>
    </div>

    <div id="confirm-delete-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-sm p-6">
            <h2 class="text-lg font-bold mb-2">Conferma Eliminazione</h2>
            <p class="text-sm text-gray-600 dark:text-gray-300 mb-4">Sei sicuro di voler eliminare questo documento? L'azione è irreversibile.</p>
            <div class="flex justify-end space-x-3">
                <button id="cancel-delete-btn" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500 font-bold py-2 px-4 rounded-lg">Annulla</button>
                <button id="confirm-delete-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Elimina</button>
            </div>
        </div>
    </div>
    
    <div id="snackbar" class="fixed bottom-6 left-1/2 -translate-x-1/2 bg-gray-800 text-white py-2 px-5 rounded-lg shadow-lg transition-opacity duration-300 opacity-0 z-50"></div>

    <div id="load-error-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex flex-col items-center justify-center p-4 z-50 text-white text-center">
        <i data-lucide="server-crash" class="w-24 h-24 text-red-400 mb-4"></i>
        <h2 class="text-2xl font-bold mb-2">Errore Critico</h2>
        <p class="mb-6 max-w-md">Impossibile caricare alcune risorse fondamentali per il funzionamento dell'applicazione. Controlla la tua connessione a internet.</p>
        <p id="missing-libs-list" class="text-sm text-gray-400 mb-6"></p>
        <button id="reload-page-btn" class="bg-blue-600 hover:bg-blue-700 font-bold py-2 px-6 rounded-lg">Ricarica Pagina</button>
    </div>

    <script>
    // --- Funzione principale dell'applicazione ---
    function initializeApp() {
        console.log("App inizializzata.");
        
        // --- Inizializzazione PDF.js Worker ---
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;
        } else {
            console.warn("Attenzione: libreria PDF.js non caricata.");
        }
        
        const docListContainer = document.getElementById('document-list-container');
        const emptyStateEl = document.getElementById('empty-state');
        const searchInput = document.getElementById('search-input');
        const sortSelect = document.getElementById('sort-select');
        const addDocBtn = document.getElementById('add-doc-btn');
        let currentFilter = {};
        let activeTagFilter = null;
        let db;
        let docIdToDelete = null;
        let editingDocId = null;
        let attachmentsToAdd = [];
        let currentPreviewDoc = null;
        let currentView = localStorage.getItem('doc-view') || 'list';
        let fullFilteredDocs = [];
        let currentPage = 1;
        let itemsPerPage = 10;

        const docModal = document.getElementById('doc-modal');
        const docForm = document.getElementById('doc-form');
        const modalTitle = document.getElementById('modal-title');
        const docIdInput = docForm['doc-id'];
        const cancelBtn = document.getElementById('cancel-btn');
        const fileInput = docForm['doc-file'];
        const ocrBtn = document.getElementById('ocr-btn');
        const ocrStatusEl = document.getElementById('ocr-status');
        const currentFileNameEl = document.getElementById('current-file-name');
        const attachmentsInput = docForm['doc-attachments'];
        const attachmentsListEl = document.getElementById('attachments-list');
        const categorySuggestions = document.getElementById('category-suggestions');
        const subcategorySuggestions = document.getElementById('subcategory-suggestions');
        const tagsSuggestions = document.getElementById('tags-suggestions');
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('sidebar-overlay');
        const menuBtn = document.getElementById('menu-btn');
        const filterTreeEl = document.getElementById('filter-tree');
        const closeSidebarBtn = document.getElementById('close-sidebar-btn');
        const resetFilterBtn = document.getElementById('reset-filter-btn');
        const previewModal = document.getElementById('preview-modal');
        const previewTitle = document.getElementById('preview-title');
        const previewContent = document.getElementById('preview-content');
        const previewAttachmentsBar = document.getElementById('preview-attachments-bar');
        const closePreviewBtn = document.getElementById('close-preview-btn');
        const printBtn = document.getElementById('print-btn');
        const downloadBtn = document.getElementById('download-btn');
        const editPreviewBtn = document.getElementById('edit-preview-btn');
        const deletePreviewBtn = document.getElementById('delete-preview-btn');
        const confirmDeleteModal = document.getElementById('confirm-delete-modal');
        const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
        const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
        const exportBtn = document.getElementById('export-data-btn');
        const importBtn = document.getElementById('import-data-btn');
        const importFileInput = document.getElementById('import-file-input');
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        const viewListBtn = document.getElementById('view-list-btn');
        const viewGridBtn = document.getElementById('view-grid-btn');
        const statsTotalDocs = document.getElementById('stats-total-docs');
        const statsTotalSize = document.getElementById('stats-total-size');
        const itemsPerPageSelect = document.getElementById('items-per-page-select');
        const loadMoreBtn = document.getElementById('load-more-btn');
        const loadErrorModal = document.getElementById('load-error-modal');
        const fieldsToHighlight = [
            docForm['doc-name'],
            docForm['doc-year'],
            docForm['doc-category'],
            docForm['doc-subcategory'],
            docForm['doc-details']
        ];
        
        const selectedTagsContainer = document.getElementById('selected-tags-container');
        const docTagsInput = document.getElementById('doc-tags-input');
        const availableTagsSection = document.getElementById('available-tags-section');
        const availableTagsContainer = document.getElementById('available-tags-container');
        const docTagsHiddenInput = document.getElementById('doc-tags');
        const categoryInput = docForm['doc-category'];

        let currentTagsSet = new Set();
        let allKnownTags = new Set();
        let categoryScopedTags = new Set();


        function getPdfjsLib() {
            if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
                return window.pdfjsLib;
            } else {
                console.error("Libreria PDF.js non caricata o non inizializzata correttamente.");
                showSnackbar("Errore: la libreria per i PDF non è stata caricata.");
                return null;
            }
        }

        function initDB() {
            const request = indexedDB.open("DocumentManagerDB_v3", 2);
            request.onerror = e => console.error("DB Error:", e.target.errorCode);
            request.onupgradeneeded = e => {
                db = e.target.result;
                let store;
                if (!db.objectStoreNames.contains("documents")) {
                    store = db.createObjectStore("documents", { keyPath: "id", autoIncrement: true });
                    store.createIndex("year_category_subcategory", ["year", "category", "subcategory"], { unique: false });
                } else {
                    store = e.target.transaction.objectStore("documents");
                }
                
                if (!store.indexNames.contains("contentHash")) {
                    store.createIndex("contentHash", "contentHash", { unique: true });
                }
            };
            request.onsuccess = e => {
                db = e.target.result;
                renderAll();
            };
        }

        function renderAll() {
            renderDocuments();
            renderFilterTree();
            updateDatalists();
            renderStats();
        }
        
        const Crud = {
            save: (doc, showNotification = true) => {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction("documents", "readwrite");
                    tx.oncomplete = () => {
                        if (showNotification) showSnackbar("Documento salvato!");
                        closeModal(docModal);
                        renderAll();
                        resolve();
                    };
                    tx.onerror = (event) => {
                        console.error("Errore transazione DB:", event.target.error);
                        if (event.target.error.name === 'ConstraintError') {
                            showSnackbar("Errore: un file con questo stesso contenuto esiste già.", true);
                        }
                        reject(event.target.error);
                    };
                    tx.objectStore("documents").put(doc);
                });
            },
            delete: (docId) => {
                const tx = db.transaction("documents", "readwrite");
                tx.objectStore("documents").delete(docId);
                tx.oncomplete = () => {
                    showSnackbar("Documento eliminato.");
                    currentPreviewDoc = null;
                    renderAll();
                    if(!previewModal.classList.contains('hidden')) closeModal(previewModal);
                };
            },
            get: (docId, callback) => {
                db.transaction("documents").objectStore("documents").get(parseInt(docId)).onsuccess = e => callback(e.target.result);
            },
            getAll: (callback) => {
                db.transaction("documents").objectStore("documents").getAll().onsuccess = e => callback(e.target.result);
            },
            clear: (callback) => {
                const tx = db.transaction("documents", "readwrite");
                tx.objectStore("documents").clear();
                tx.oncomplete = callback;
            }
        };
        
        function calculateSimilarity(s1, s2) {
            let longer = s1;
            let shorter = s2;
            if (s1.length < s2.length) {
                longer = s2;
                shorter = s1;
            }
            const longerLength = longer.length;
            if (longerLength === 0) {
                return 1.0;
            }
            return (longerLength - levenshteinDistance(longer, shorter)) / parseFloat(longerLength);
        }

        function levenshteinDistance(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i == 0) {
                        costs[j] = j;
                    } else {
                        if (j > 0) {
                            let newValue = costs[j - 1];
                            if (s1.charAt(i - 1) != s2.charAt(j - 1)) {
                                newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                            }
                            costs[j - 1] = lastValue;
                            lastValue = newValue;
                        }
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }
            return costs[s2.length];
        }
        
        function findBestMatchForWord(word, wordList) {
            let bestScore = 0;
            for (const ocrWord of wordList) {
                const score = calculateSimilarity(word, ocrWord);
                if (score > bestScore) {
                    bestScore = score;
                }
            }
            return bestScore;
        }

        function getMimeTypeFromName(fileName) {
            if (!fileName || !fileName.includes('.')) return 'application/octet-stream';
            const extension = fileName.split('.').pop().toLowerCase();
            switch (extension) {
                case 'jpg': case 'jpeg': return 'image/jpeg';
                case 'png': return 'image/png';
                case 'gif': return 'image/gif';
                case 'webp': return 'image/webp';
                case 'svg': return 'image/svg+xml';
                case 'pdf': return 'application/pdf';
                default: return 'application/octet-stream';
            }
        }

        function getExistingCategoriesAndSubcategories() {
            return new Promise(resolve => {
                Crud.getAll(docs => {
                    const existingCategories = new Set();
                    const existingSubcategories = new Set();
                    docs.forEach(doc => {
                        if (doc.category) existingCategories.add(doc.category);
                        if (doc.subcategory) existingSubcategories.add(doc.subcategory);
                    });
                    resolve({ existingCategories, existingSubcategories });
                });
            });
        }

        const dataURLtoBlob = (dataurl) => {
            if (!dataurl || !dataurl.includes(',')) {
                console.error("Invalid dataURL passed to dataURLtoBlob");
                return null;
            }
            const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
                  bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while(n--){ u8arr[n] = bstr.charCodeAt(n); }
            return new Blob([u8arr], {type:mime});
        }

        const readFileAsDataURL = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve({
                    fileData: reader.result,
                    fileName: file.name,
                    fileType: file.type
                });
                reader.onerror = () => {
                    reject(new Error(`Impossibile leggere il file "${file.name}"`));
                };
                reader.readAsDataURL(file);
            });
        };

        async function calculateFileHash(file) {
            const buffer = await file.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }

        function checkForDuplicate(hash) {
            return new Promise((resolve, reject) => {
                if (!db) return resolve(null);
                const tx = db.transaction("documents", "readonly");
                const store = tx.objectStore("documents");
                const index = store.index("contentHash");
                const request = index.get(hash);
                request.onsuccess = () => resolve(request.result || null);
                request.onerror = (e) => reject(e.target.error);
            });
        }

        const getBase64Size = (base64) => {
            if (!base64 || typeof base64 !== 'string') return 0;
            const stringLength = base64.length - base64.indexOf(',');
            const sizeInBytes = 4 * Math.ceil(stringLength / 3) * 0.5624896334383812;
            return sizeInBytes;
        };

        const formatBytes = (bytes, decimals = 2) => {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        const highlightField = (element) => {
            if (element && element.value) {
                element.classList.add('highlight-suggestion');
            }
        };

        const clearAllHighlights = () => {
            fieldsToHighlight.forEach(field => field.classList.remove('highlight-suggestion'));
        };

        function parseFilenameForMetadata(filename) {
            if (!filename) return;
            const nameWithoutExt = filename.substring(0, filename.lastIndexOf('.')) || filename;
            const nameInput = docForm['doc-name'];
            if (!nameInput.value) {
                nameInput.value = nameWithoutExt.replace(/[-_]/g, ' ');
                highlightField(nameInput);
            }
            const yearInput = docForm['doc-year'];
            if (!yearInput.value) {
                const yearMatch = nameWithoutExt.match(/\b(19|20)\d{2}\b/);
                if (yearMatch) {
                    yearInput.value = yearMatch[0];
                    highlightField(yearInput);
                }
            }
            const categoryInput = docForm['doc-category'];
            const subcategoryInput = docForm['doc-subcategory'];
            if (!categoryInput.value) {
                const parts = nameWithoutExt.replace(/\b(19|20)\d{2}\b/, '').split(/[-_ ]+/).filter(p => p.toLowerCase() !== 'fattura' && p.toLowerCase() !== 'bolletta');
                if (parts.length > 0) {
                    categoryInput.value = parts[0];
                    highlightField(categoryInput);
                }
                if (parts.length > 1 && !subcategoryInput.value) {
                    subcategoryInput.value = parts[1];
                    highlightField(subcategoryInput);
                }
            }
        }
        
        async function runOCR() {
            const file = fileInput.files[0];
            if (!file || (!file.type.startsWith('image/') && file.type !== 'application/pdf')) {
                showSnackbar("Seleziona un file immagine o PDF per l'analisi OCR.");
                return;
            }

            ocrStatusEl.innerHTML = `<div class="ocr-loader"></div> <span>Inizializzazione OCR...</span>`;
            ocrBtn.disabled = true;
            
            const worker = await Tesseract.createWorker('ita', 1, {
                logger: m => {
                    if (m.status === 'recognizing text') {
                        const progress = (m.progress * 100).toFixed(0);
                        ocrStatusEl.innerHTML = `<div class="ocr-loader"></div> <span>Analisi in corso (${progress}%)...</span>`;
                    } else if (m.status === 'loading language model') {
                         ocrStatusEl.innerHTML = `<div class="ocr-loader"></div> <span>Caricamento modello lingua...</span>`;
                    }
                },
            });

            try {
                let imageSource;
                if (file.type.startsWith('image/')) {
                    imageSource = file;
                } else if (file.type === 'application/pdf') {
                    ocrStatusEl.innerHTML = `<div class="ocr-loader"></div> <span>Caricamento PDF...</span>`;
                    const pdfjsLib = getPdfjsLib(); 
                    if (!pdfjsLib) throw new Error("Libreria PDF non disponibile.");

                    const arrayBuffer = await file.arrayBuffer();
                    const typedarray = new Uint8Array(arrayBuffer);
                    const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                    const page = await pdf.getPage(1);
                    
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({ canvasContext: context, viewport: viewport }).promise;
                    imageSource = canvas;
                }
                
                const { data: { text } } = await worker.recognize(imageSource);
                await parseOCRText(text);
                ocrStatusEl.innerHTML = `<i data-lucide="check-circle" class="w-4 h-4 text-green-500"></i> <span>Analisi completata. Controlla i campi.</span>`;
            } catch (error) {
                console.error("OCR Error:", error);
                ocrStatusEl.innerHTML = `<i data-lucide="x-circle" class="w-4 h-4 text-red-500"></i> <span class="text-left">Errore durante l'analisi.</span>`;
            } finally {
                await worker.terminate();
                ocrBtn.disabled = false;
                lucide.createIcons();
            }
        }

        async function parseOCRText(text) {
            if (!text) return;

            const detailsInput = docForm['doc-details'];
            let detailsFound = false; 

            const setField = (element, value) => {
                if (element && !element.value && value) {
                    element.value = value.trim();
                    highlightField(element);
                }
            };
            
            const appendToDetails = (label, value) => {
                if (value) {
                    detailsFound = true; 
                    const cleanLabel = label.trim();
                    const cleanValue = value.trim();
                    const existingDetails = detailsInput.value;
                    const labelRegex = new RegExp(`^${cleanLabel}:|\\n${cleanLabel}:`, 'm');
                    if (!labelRegex.test(existingDetails)) {
                        detailsInput.value += (existingDetails ? '\n' : '') + `${cleanLabel}: ${cleanValue}`;
                        highlightField(detailsInput);
                    }
                }
            };

            const addTagFromOCR = (tag) => {
                if (!tag) return;
                const cleanedTag = tag.trim();
                if (cleanedTag && !currentTagsSet.has(cleanedTag)) {
                    currentTagsSet.add(cleanedTag);
                    updateTagsUI();
                    highlightField(selectedTagsContainer); 
                }
            };

            const { existingCategories, existingSubcategories } = await getExistingCategoriesAndSubcategories();
            const sortedCategories = [...existingCategories].sort((a, b) => b.length - a.length);
            const sortedSubcategories = [...existingSubcategories].sort((a, b) => b.length - a.length);
            const ocrWords = text.toLowerCase().replace(/[.,/#!$%\^&*;:{}=\-_`~()]/g, "").split(/\s+/).filter(Boolean);
            const WORD_SIMILARITY_THRESHOLD = 0.8; 

            if (!docForm['doc-category'].value) {
                for (const category of sortedCategories) {
                    const catWords = category.toLowerCase().split(' ');
                    let allWordsFound = true;
                    for (const catWord of catWords) {
                        const bestMatchScore = findBestMatchForWord(catWord, ocrWords);
                        if (bestMatchScore < WORD_SIMILARITY_THRESHOLD) {
                            allWordsFound = false;
                            break; 
                        }
                    }
                    if (allWordsFound) {
                        setField(docForm['doc-category'], category);
                        break; 
                    }
                }
            }

            if (!docForm['doc-subcategory'].value) {
                for (const subcategory of sortedSubcategories) {
                    const subCatWords = subcategory.toLowerCase().split(' ');
                    let allWordsFound = true;
                    for (const subCatWord of subCatWords) {
                        const bestMatchScore = findBestMatchForWord(subCatWord, ocrWords);
                        if (bestMatchScore < WORD_SIMILARITY_THRESHOLD) {
                            allWordsFound = false;
                            break;
                        }
                    }
                    if (allWordsFound) {
                        setField(docForm['doc-subcategory'], subcategory);
                        break; 
                    }
                }
            }
            
            if (!docForm['doc-category'].value) {
                const recognizers = [
                    { name: 'Luce', keywords: /enel|servizio elettrico|e-distribuzione|a2a energia/i, cat: 'Bollette', sub: 'Luce' },
                    { name: 'Gas', keywords: /enel energia|eni|plenitude|snam|italgas|a2a/i, cat: 'Bollette', sub: 'Gas' },
                    { name: 'Acqua', keywords: /acea|acquedotto|publiacqua|acque/i, cat: 'Bollette', sub: 'Acqua' },
                    { name: 'Telefonia', keywords: /tim|telecom|vodafone|wind|tre|iliad|fastweb|sky wifi/i, cat: 'Bollette', sub: 'Telefonia' },
                    { name: 'Rifiuti', keywords: /tari|tassa sui rifiuti|azienda municipalizzata/i, cat: 'Tasse', sub: 'Rifiuti' },
                    { name: 'Assicurazione', keywords: /allianz|generali|unipolsai|cattolica assicurazioni|reale mutuale/i, cat: 'Assicurazioni', sub: 'Polizza' },
                    { name: 'Sanità', keywords: /referto|ricetta medica|asl|cup|azienda sanitaria|analisi/i, cat: 'Sanità', sub: 'Referto' },
                    { name: 'Multe', keywords: /multa|sanzione amministrativa|verbale di accertamento|polizia locale/i, cat: 'Multe', sub: 'Violazione' },
                    { name: 'Banca', keywords: /estratto conto|banca|intesa sanpaolo|unicredit|bper/i, cat: 'Banca', sub: 'Estratto Conto'},
                    { name: 'Fattura', keywords: /fattura|ricevuta fiscale|documento commerciale/i, cat: 'Fatture', sub: 'Generica' }
                ];
                for (const rec of recognizers) {
                    if (rec.keywords.test(text)) {
                        setField(docForm['doc-category'], rec.cat);
                        setField(docForm['doc-subcategory'], rec.sub);
                        break; 
                    }
                }
            }

            const oggettoMatch = text.match(/(?:^|\n)\s*oggetto:?\s*(.*)/i);
            if (oggettoMatch && oggettoMatch[1]) appendToDetails('Oggetto', oggettoMatch[1].trim());

            const yearMatch = text.match(/\b(20\d{2})\b/);
            if (yearMatch) setField(docForm['doc-year'], yearMatch[0]);

            const dateMatch = text.match(/\b(\d{1,2}[\s\/\-\.]\d{1,2}[\s\/\-\.]\d{2,4})\b/);
            if(dateMatch) appendToDetails('Data Doc.', dateMatch[0]);

            const scadenzaMatch = text.match(/(?:scadenza|pagare entro il|da versare entro)[\s\S]*?(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/i);
            if (scadenzaMatch && scadenzaMatch[1]) {
                appendToDetails('Scadenza', scadenzaMatch[1]);
                addTagFromOCR('Da Pagare');
            }
            
            const importoMatch = text.match(/(?:totale|importo|totale da pagare)[\s\S]*?€?\s*(\d+[,.]\d{2})/i);
            if (importoMatch && importoMatch[1]) appendToDetails('Importo', `€ ${importoMatch[1].replace(',', '.')}`);

            const pivaMatch = text.match(/(?:p\.?\s?iva|partita iva)[\s\S]*?(\d{11})/i);
            if (pivaMatch && pivaMatch[1]) appendToDetails('P.IVA', pivaMatch[1]);
            
            const cfMatch = text.match(/(?:c\.?\s?f\.?|codice fiscale)[\s\S]*?([A-Z]{6}\d{2}[A-Z]\d{2}[A-Z]\d{3}[A-Z])/i);
            if (cfMatch && cfMatch[1]) appendToDetails('Cod. Fiscale', cfMatch[1]);
            
            const ibanMatch = text.match(/\b(IT\d{2}[A-Z]\d{22})\b/i);
            if (ibanMatch && ibanMatch[0]) appendToDetails('IBAN', ibanMatch[0]);

            const docNumMatch = text.match(/(?:fattura|documento|polizza|verbale|bolletta|contratto)\s*(?:n\.?|numero|nr\.?)?\s*([a-zA-Z0-9\/\-]+)/i);
            if(docNumMatch && docNumMatch[1]) appendToDetails(`N. ${docNumMatch[0].split(/[\s\n\r]/)[0]}`, docNumMatch[1]);
            
            if (/quietanza|pagamento ricevuto|pagato|pagata/i.test(text)) {
                addTagFromOCR('Pagato');
                if (currentTagsSet.has('Da Pagare')) {
                    currentTagsSet.delete('Da Pagare');
                    updateTagsUI();
                }
            }
            if (/multa|sanzione|urgente|sollecito|sinistro/i.test(text)) addTagFromOCR('Urgente');

            if (!detailsFound && text.trim().length > 0 && !detailsInput.value) {
                const textSnippet = text.split('\n').slice(0, 5).join('\n').trim();
                detailsInput.value = `Testo riconosciuto (estratto):\n----------------------------\n${textSnippet}`;
                highlightField(detailsInput);
            }
        }
        
        async function renderPdfToCanvas(canvas, fileData, options = {}) {
            if (!canvas || !fileData) return;
            try {
                const pdfjsLib = getPdfjsLib();
                if (!pdfjsLib) throw new Error("PDF.js library not found");

                const typedarray = new Uint8Array(atob(fileData.split(',')[1]).split('').map(char => char.charCodeAt(0)));
                const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                const page = await pdf.getPage(1);
                
                let scale = 1.0;
                const viewport = page.getViewport({ scale: scale });
                
                if (options.isThumbnail) {
                    scale = 128 / viewport.height;
                } else if (options.isModal) {
                    const container = canvas.parentElement;
                    if (container) {
                         const maxWidth = container.clientWidth;
                         const maxHeight = container.clientHeight;
                         scale = Math.min(maxWidth / viewport.width, maxHeight / viewport.height);
                    }
                } else {
                    scale = (canvas.parentElement.clientWidth - 20) / viewport.width;
                }

                const scaledViewport = page.getViewport({ scale: scale });
                const context = canvas.getContext('2d');
                canvas.height = scaledViewport.height;
                canvas.width = scaledViewport.width;
                await page.render({ canvasContext: context, viewport: scaledViewport }).promise;
            } catch (error) {
                console.error(`Error rendering PDF preview:`, error);
                const container = canvas.parentElement;
                if (container) {
                    container.innerHTML = `<div class="text-center text-red-500 p-4"><i data-lucide="file-warning" class="mx-auto h-16 w-16"></i><p class="mt-2 text-sm">Errore anteprima PDF</p></div>`;
                    lucide.createIcons();
                }
            }
        }

        function handleFilePreview(event) {
            const file = event.target.files[0];
            const previewContainer = document.getElementById('file-preview-container');
            const previewEl = document.getElementById('file-preview');
            ocrBtn.disabled = !file || (!file.type.startsWith('image/') && file.type !== 'application/pdf');
            if (file) parseFilenameForMetadata(file.name);
            previewContainer.classList.add('hidden');
            previewEl.innerHTML = '';
            if (!file) return;
            previewContainer.classList.remove('hidden');
            const reader = new FileReader();
            reader.onload = e => {
                if (file.type.startsWith('image/')) {
                    previewEl.innerHTML = `<img src="${e.target.result}" class="max-w-full max-h-40 h-auto rounded-md mx-auto">`;
                } else if (file.type === 'application/pdf') {
                    previewEl.innerHTML = `<canvas class="max-w-full h-auto rounded-md mx-auto"></canvas>`;
                    renderPdfToCanvas(previewEl.querySelector('canvas'), e.target.result);
                } else {
                    previewEl.innerHTML = `<div class="text-center p-4"><i data-lucide="file-text" class="mx-auto h-16 w-16 text-gray-400"></i><p class="mt-2 text-sm text-gray-600 dark:text-gray-300 truncate">${file.name}</p></div>`;
                    lucide.createIcons();
                }
            };
            reader.readAsDataURL(file);
        }
        
        function renderDocuments() {
            currentPage = 1;
            Crud.getAll(docs => {
                const searchTerm = searchInput.value.toLowerCase();
                
                const filteredDocs = docs.filter(doc => {
                    const inCategoryFilter = (!currentFilter.year || doc.year == currentFilter.year) &&
                                     (!currentFilter.category || doc.category === currentFilter.category) &&
                                     (!currentFilter.subcategory || doc.subcategory === currentFilter.subcategory);
                    const inTagFilter = !activeTagFilter || (doc.tags && doc.tags.includes(activeTagFilter));
                    const inSearch = searchTerm === '' || 
                                     doc.displayName.toLowerCase().includes(searchTerm) ||
                                     doc.category.toLowerCase().includes(searchTerm) ||
                                     doc.subcategory.toLowerCase().includes(searchTerm) ||
                                     (doc.details && doc.details.toLowerCase().includes(searchTerm)) ||
                                     (doc.tags && doc.tags.some(tag => tag.toLowerCase().includes(searchTerm)));
                    return inCategoryFilter && inTagFilter && inSearch;
                });

                const sortValue = sortSelect.value;
                filteredDocs.sort((a, b) => {
                    switch (sortValue) {
                        case 'name_asc': return a.displayName.localeCompare(b.displayName);
                        case 'name_desc': return b.displayName.localeCompare(a.displayName);
                        case 'year_asc': return a.year - b.year;
                        case 'year_desc': return b.year - a.year;
                        case 'date_asc': return a.uploadDate - b.uploadDate;
                        case 'date_desc': default: return b.uploadDate - a.uploadDate;
                    }
                });
                fullFilteredDocs = filteredDocs;
                displayCurrentPage();
            });
        }
        
        function displayCurrentPage(append = false) {
            if (!append) docListContainer.innerHTML = '';
            const start = (currentPage - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const docsToRender = fullFilteredDocs.slice(start, end);

            if (fullFilteredDocs.length === 0 && !append) {
                emptyStateEl.classList.remove('hidden');
                loadMoreBtn.classList.add('hidden');
            } else {
                emptyStateEl.classList.add('hidden');
                
                if (currentView === 'list') {
                    if(!append) docListContainer.className = 'space-y-3';
                    docsToRender.forEach(createDocCard);
                } else {
                    if(!append) docListContainer.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4';
                    docsToRender.forEach(createDocGridItem);
                }

                if (fullFilteredDocs.length > end) {
                    loadMoreBtn.classList.remove('hidden');
                } else {
                    loadMoreBtn.classList.add('hidden');
                }
            }
            lucide.createIcons();
        }

        function createDocCard(doc) {
            const details = document.createElement('details');
            details.className = 'bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden';
            
            const tagsHTML = doc.tags && doc.tags.length > 0 ? `
                <strong class="text-gray-500 dark:text-gray-400 col-span-1">Tags:</strong>
                <div class="col-span-3 flex flex-wrap gap-2">
                    ${doc.tags.map(tag => `<button class="tag-link bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-xs font-medium px-2.5 py-0.5 rounded-full hover:bg-blue-200 dark:hover:bg-blue-800" data-tag="${tag}">${tag}</button>`).join('')}
                </div>` : '';

            const detailsHTML = doc.details ? `
                <strong class="text-gray-500 dark:text-gray-400 col-span-1 mt-2">Dettagli:</strong>
                <p class="col-span-3 text-gray-700 dark:text-gray-300 whitespace-pre-wrap">${doc.details}</p>` : '';

            const attachmentsHTML = doc.attachments && doc.attachments.length > 0 ? `
                <strong class="text-gray-500 dark:text-gray-400 col-span-1 mt-2">Allegati:</strong>
                <div class="col-span-3 space-y-1">
                    ${doc.attachments.map((att, index) => `<a href="#" class="attachment-link text-blue-600 dark:text-blue-400 hover:underline text-sm flex items-center gap-1" data-doc-id="${doc.id}" data-attachment-index="${index}"><i data-lucide="paperclip" class="w-3 h-3"></i> ${att.fileName}</a>`).join('')}
                </div>` : '';

            details.innerHTML = `
                <summary class="flex justify-between items-center p-4 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700/50">
                    <div>
                        <span class="font-semibold">${doc.displayName}</span>
                        <div class="text-xs text-gray-500">${doc.category} / ${doc.subcategory}</div>
                    </div>
                    <div class="flex items-center gap-2">
                         <button class="preview-btn p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-600" data-id="${doc.id}" title="Apri anteprima">
                            <i data-lucide="eye" class="w-5 h-5"></i>
                         </button>
                         <i data-lucide="chevron-right" class="summary-arrow w-5 h-5"></i>
                    </div>
                </summary>
                <div class="details-content max-h-0 bg-gray-50 dark:bg-gray-700/50 p-4 border-t border-gray-200 dark:border-gray-700">
                    <div class="grid grid-cols-4 gap-x-4 gap-y-2 text-sm">
                        <strong class="text-gray-500 dark:text-gray-400">Anno:</strong><span>${doc.year}</span>
                        <strong class="text-gray-500 dark:text-gray-400">Caricato:</strong><span>${new Date(doc.uploadDate).toLocaleDateString('it-IT')}</span>
                        ${tagsHTML}
                        ${detailsHTML}
                        ${attachmentsHTML}
                    </div>
                    <div class="mt-4 flex justify-end gap-3">
                        <button class="edit-doc-btn text-sm flex items-center gap-1 text-blue-600 dark:text-blue-400 hover:underline" data-id="${doc.id}">
                            <i data-lucide="edit-2" class="w-4 h-4"></i> Modifica
                        </button>
                        <button class="delete-doc-btn text-sm flex items-center gap-1 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 hover:underline" data-id="${doc.id}">
                            <i data-lucide="trash-2" class="w-4 h-4"></i> Elimina
                        </button>
                    </div>
                </div>`;
            docListContainer.appendChild(details);
        }

        function createDocGridItem(doc) {
            const card = document.createElement('div');
            card.className = 'preview-btn bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-hidden flex flex-col cursor-pointer transition-transform transform hover:scale-105';
            card.dataset.id = doc.id;
            
            let previewHTML = '';
            
            if (doc.fileType && doc.fileType.startsWith('image/')) {
                previewHTML = `<div class="w-full h-32 bg-gray-100 dark:bg-gray-700 flex items-center justify-center"><img src="${doc.fileData}" class="w-full h-full object-cover" alt="Anteprima di ${doc.displayName}"></div>`;
            } else if (doc.fileType === 'application/pdf') {
                previewHTML = `<div class="w-full h-32 bg-gray-100 dark:bg-gray-700 flex items-center justify-center overflow-hidden"><canvas id="pdf-canvas-${doc.id}" class="max-w-full max-h-full"></canvas></div>`;
                setTimeout(() => renderPdfToCanvas(document.getElementById(`pdf-canvas-${doc.id}`), doc.fileData, { isThumbnail: true }), 0);
            } else {
                previewHTML = `<div class="w-full h-32 bg-gray-100 dark:bg-gray-700 flex items-center justify-center"><i data-lucide="file-text" class="w-12 h-12 text-gray-400"></i></div>`;
            }

            card.innerHTML = `
                ${previewHTML}
                <div class="p-3 flex-grow flex flex-col">
                    <h3 class="font-semibold text-sm truncate flex-grow" title="${doc.displayName}">${doc.displayName}</h3>
                    <p class="text-xs text-gray-500 truncate">${doc.category} / ${doc.subcategory}</p>
                </div>
            `;
            docListContainer.appendChild(card);
            if (!doc.fileType || (doc.fileType !== 'application/pdf' && !doc.fileType.startsWith('image/'))) {
                lucide.createIcons({nodes: [card]});
            }
        }

        function renderFilterTree() {
            Crud.getAll(docs => {
                const tree = docs.reduce((acc, doc) => {
                    acc[doc.year] = acc[doc.year] || {};
                    acc[doc.year][doc.category] = acc[doc.year][doc.category] || new Set();
                    if(doc.subcategory) acc[doc.year][doc.category].add(doc.subcategory);
                    return acc;
                }, {});
                let html = '';
                const sortedYears = Object.keys(tree).sort((a, b) => b - a);
                sortedYears.forEach(year => {
                    const isYearActive = currentFilter.year == year && !currentFilter.category;
                    const isYearInPath = currentFilter.year == year;
                    html += `<details ${isYearInPath ? 'open' : ''}><summary class="p-1 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 ${isYearActive ? 'active' : ''}" data-filter-type="year" data-filter-value="${year}"><span>${year}</span></summary><ul class="pl-4 ml-1 border-l border-gray-200 dark:border-gray-700">`;
                    Object.keys(tree[year]).sort().forEach(category => {
                        const isCatActive = currentFilter.year == year && currentFilter.category === category && !currentFilter.subcategory;
                        const isCatInPath = isYearInPath && currentFilter.category === category;
                        html += `<li><details ${isCatInPath ? 'open' : ''}><summary class="p-1 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 ${isCatActive ? 'active' : ''}" data-filter-type="category" data-filter-value="${category}" data-filter-parent-year="${year}"><span>${category}</span></summary><ul class="pl-4 ml-1 border-l border-gray-200 dark:border-gray-700">`;
                        [...tree[year][category]].sort().forEach(subcategory => {
                            const isSubActive = isCatInPath && currentFilter.subcategory === subcategory;
                            html += `<li class="p-1 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 ${isSubActive ? 'active' : ''}" data-filter-type="subcategory" data-filter-value="${subcategory}" data-filter-parent-year="${year}" data-filter-parent-category="${category}"><span>${subcategory}</span></li>`;
                        });
                        html += '</ul></details></li>';
                    });
                    html += '</ul></details>';
                });
                filterTreeEl.innerHTML = html;
            });
        }
        
        function updateDatalists() {
            Crud.getAll(docs => {
                const categories = new Set(), subcategories = new Set(), allTags = new Set();
                docs.forEach(doc => {
                    if (doc.category) categories.add(doc.category);
                    if (doc.subcategory) subcategories.add(doc.subcategory);
                    if (doc.tags) doc.tags.forEach(tag => allTags.add(tag));
                });
                const populate = (datalist, items) => {
                    datalist.innerHTML = '';
                    [...items].sort().forEach(item => datalist.innerHTML += `<option value="${item}">`);
                };
                populate(categorySuggestions, categories);
                populate(subcategorySuggestions, subcategories);
                populate(tagsSuggestions, allTags);
                allKnownTags = allTags;
            });
        }

        function updateTagsUI() {
            if (!selectedTagsContainer) return;
            docTagsHiddenInput.value = [...currentTagsSet].join(', ');
            while (selectedTagsContainer.firstChild && selectedTagsContainer.firstChild !== docTagsInput) {
                selectedTagsContainer.removeChild(selectedTagsContainer.firstChild);
            }
            currentTagsSet.forEach(tag => {
                const tagEl = document.createElement('span');
                tagEl.className = 'flex items-center gap-1 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-sm font-medium pl-2.5 pr-1 py-0.5 rounded-full';
                tagEl.innerHTML = `${tag}<button type="button" class="remove-tag-btn rounded-full hover:bg-blue-200 dark:hover:bg-blue-700 p-0.5" data-tag="${tag}"><i data-lucide="x" class="w-3 h-3"></i></button>`;
                selectedTagsContainer.insertBefore(tagEl, docTagsInput);
            });
            availableTagsContainer.innerHTML = '';
            if (categoryScopedTags.size > 0) {
                const availableTags = [...categoryScopedTags].filter(t => !currentTagsSet.has(t)).sort();
                if (availableTags.length > 0) {
                    availableTags.forEach(tag => {
                        const tagBtn = document.createElement('button');
                        tagBtn.type = 'button';
                        tagBtn.className = 'add-tag-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 px-2 py-1 rounded-md';
                        tagBtn.textContent = tag;
                        tagBtn.dataset.tag = tag;
                        availableTagsContainer.appendChild(tagBtn);
                    });
                    availableTagsSection.classList.remove('hidden');
                } else {
                    availableTagsSection.classList.add('hidden');
                }
            } else {
                availableTagsSection.classList.add('hidden');
            }
            lucide.createIcons();
        }
        
        async function updateCategoryScopedTags(category) {
            if (!category || category.trim() === '') {
                categoryScopedTags = new Set();
            } else {
                await new Promise(resolve => {
                    Crud.getAll(docs => {
                        const tags = new Set();
                        docs.filter(doc => doc.category === category)
                            .forEach(doc => {
                                if (doc.tags) doc.tags.forEach(tag => tags.add(tag));
                            });
                        categoryScopedTags = tags;
                        resolve();
                    });
                });
            }
            updateTagsUI();
        }

        function addTag(tag) {
            const cleanedTag = tag.trim();
            if (cleanedTag) {
                currentTagsSet.add(cleanedTag);
                updateTagsUI();
            }
        }
        
        function renderStats() {
            Crud.getAll(docs => {
                statsTotalDocs.textContent = docs.length;
                let totalSize = 0;
                docs.forEach(doc => {
                    if(doc.fileData) totalSize += getBase64Size(doc.fileData);
                    if(doc.attachments) {
                        doc.attachments.forEach(att => totalSize += getBase64Size(att.fileData));
                    }
                });
                statsTotalSize.textContent = formatBytes(totalSize);
            });
        }
        
        const renderPreviewContent = (fileData, fileType, fileName) => {
            previewContent.innerHTML = '';
            if (fileType.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = fileData;
                img.className = 'max-w-full max-h-full object-contain';
                previewContent.appendChild(img);
            } else if (fileType === 'application/pdf') {
                const canvas = document.createElement('canvas');
                canvas.className = 'max-w-full max-h-full object-contain bg-white rounded-md shadow-lg';
                previewContent.appendChild(canvas);
                renderPdfToCanvas(canvas, fileData, { isModal: true });
            } else {
                previewContent.innerHTML = `
                    <div class="text-center text-white p-8">
                        <i data-lucide="file-text" class="mx-auto h-32 w-32"></i>
                        <p class="mt-4">Anteprima non disponibile per ${fileName}</p>
                    </div>`;
                lucide.createIcons();
            }
        }
        
        function showPreviewModal(docId, attachmentIndex = -1) {
            Crud.get(docId, doc => {
                if(!doc) return;
                currentPreviewDoc = doc;
                previewTitle.textContent = doc.displayName;
                let fileToShow = { data: doc.fileData, type: doc.fileType, name: doc.fileName };
                if (attachmentIndex > -1 && doc.attachments?.[attachmentIndex]) {
                    const att = doc.attachments[attachmentIndex];
                    fileToShow = { data: att.fileData, type: att.fileType, name: att.fileName };
                }
                renderPreviewContent(fileToShow.data, fileToShow.type, fileToShow.name);
                previewAttachmentsBar.innerHTML = '';
                if (doc.attachments && doc.attachments.length > 0) {
                    let attachmentsHTML = `<button class="attachment-preview-btn inline-block p-2 rounded-md hover:bg-gray-600 ${attachmentIndex === -1 ? 'bg-blue-600' : ''}" data-index="-1">${doc.fileName} (Principale)</button>`;
                    doc.attachments.forEach((att, index) => {
                        attachmentsHTML += `<button class="attachment-preview-btn inline-block p-2 rounded-md hover:bg-gray-600 ${attachmentIndex === index ? 'bg-blue-600' : ''}" data-index="${index}">${att.fileName}</button>`;
                    });
                    previewAttachmentsBar.innerHTML = attachmentsHTML;
                    previewAttachmentsBar.classList.remove('hidden');
                } else {
                    previewAttachmentsBar.classList.add('hidden');
                }
                openModal(previewModal);
            });
        }
        
        const openAddModal = () => {
            editingDocId = null;
            docForm.reset();
            clearAllHighlights();
            attachmentsToAdd = [];
            attachmentsListEl.innerHTML = '';
            currentFileNameEl.textContent = '';
            fileInput.setAttribute('required', 'true');
            modalTitle.textContent = "Aggiungi Documento";
            ocrBtn.disabled = true;
            ocrStatusEl.innerHTML = '';
            currentTagsSet = new Set();
            updateCategoryScopedTags('');
            openModal(docModal);
        }

        const openEditModal = (docId) => {
            Crud.get(docId, doc => {
                if (!doc) return;
                editingDocId = doc.id;
                docForm.reset();
                clearAllHighlights();
                attachmentsToAdd = [];
                modalTitle.textContent = "Modifica Documento";
                docIdInput.value = doc.id;
                docForm['doc-name'].value = doc.displayName;
                docForm['doc-year'].value = doc.year;
                docForm['doc-category'].value = doc.category;
                docForm['doc-subcategory'].value = doc.subcategory;
                docForm['doc-details'].value = doc.details || '';
                currentTagsSet = new Set(doc.tags || []);
                updateCategoryScopedTags(doc.category);
                currentFileNameEl.textContent = `File attuale: ${doc.fileName}. Selezionane uno nuovo per sostituirlo.`;
                fileInput.removeAttribute('required');
                ocrBtn.disabled = true;
                ocrStatusEl.innerHTML = '';
                attachmentsListEl.innerHTML = (doc.attachments || []).map((att, index) =>
                    `<div class="flex justify-between items-center bg-gray-100 dark:bg-gray-700 p-1 rounded"><span>${att.fileName}</span><button type="button" class="remove-attachment-btn text-red-500 p-1" data-index="${index}"><i data-lucide="x" class="w-4 h-4"></i></button></div>`
                ).join('');
                lucide.createIcons();
                openModal(docModal);
            });
        };

        function showSnackbar(message, isError = false) {
            const el = document.getElementById('snackbar');
            el.textContent = message;
            el.style.backgroundColor = isError ? '#ef4444' : ''; 
            el.style.opacity = '1';
            setTimeout(() => { el.style.opacity = '0'; }, 3000);
        }
        
        const openModal = (modalEl) => modalEl.classList.remove('hidden');
        const closeModal = (modalEl) => {
            modalEl.classList.add('hidden');
            if (modalEl === docModal) {
                handleFilePreview({ target: { files: [] } });
            }
        };

        function updateViewButtons(view) {
            if (view === 'list') {
                viewListBtn.classList.add('text-blue-500', 'bg-blue-50', 'dark:bg-gray-700');
                viewGridBtn.classList.remove('text-blue-500', 'bg-blue-50', 'dark:bg-gray-700');
            } else {
                viewGridBtn.classList.add('text-blue-500', 'bg-blue-50', 'dark:bg-gray-700');
                viewListBtn.classList.remove('text-blue-500', 'bg-blue-50', 'dark:bg-gray-700');
            }
        }

        function setView(view) {
            currentView = view;
            localStorage.setItem('doc-view', view);
            updateViewButtons(view);
            renderDocuments();
        }

        const applyTheme = (theme) => {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        };
        themeToggleBtn.addEventListener('click', () => {
            const isDark = document.documentElement.classList.contains('dark');
            const newTheme = isDark ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
        });

        menuBtn.addEventListener('click', () => {
            sidebar.classList.remove('-translate-x-full');
            overlay.classList.remove('hidden');
        });
        const closeSidebar = () => {
            sidebar.classList.add('-translate-x-full');
            overlay.classList.add('hidden');
        };
        overlay.addEventListener('click', closeSidebar);
        closeSidebarBtn.addEventListener('click', closeSidebar);
        resetFilterBtn.addEventListener('click', () => {
            currentFilter = {};
            activeTagFilter = null;
            renderAll();
        });

        filterTreeEl.addEventListener('click', e => {
            const target = e.target.closest('summary, li[data-filter-type="subcategory"]');
            if (!target) return;
            e.preventDefault();
            const { filterType, filterValue, filterParentYear, filterParentCategory } = target.dataset;
            
            if (filterType === 'subcategory') {
                currentFilter = { year: filterParentYear, category: filterParentCategory, subcategory: filterValue };
                closeSidebar();
            } else if (target.tagName === 'SUMMARY') {
                const detailsElement = target.parentElement;
                
                const isYearActive = currentFilter.year == filterValue && !currentFilter.category;
                const isCatActive = currentFilter.year == filterParentYear && currentFilter.category === filterValue && !currentFilter.subcategory;

                if (isYearActive) {
                    currentFilter = {};
                } else if (isCatActive) {
                    currentFilter = { year: filterParentYear };
                } else {
                    if (filterType === 'year') currentFilter = { year: filterValue };
                    else if (filterType === 'category') currentFilter = { year: filterParentYear, category: filterValue };
                }
                
                if(!detailsElement.hasAttribute('open')) {
                    detailsElement.setAttribute('open', '');
                }
            }
            renderAll();
        });

        addDocBtn.addEventListener('click', openAddModal);
        cancelBtn.addEventListener('click', () => closeModal(docModal));
        fileInput.addEventListener('change', handleFilePreview);
        ocrBtn.addEventListener('click', runOCR);
        
        attachmentsInput.addEventListener('change', (e) => {
            attachmentsToAdd = [...e.target.files];
            attachmentsListEl.innerHTML += attachmentsToAdd.map(file => 
                `<div class="bg-blue-100 dark:bg-blue-900 p-1 rounded">Nuovo: ${file.name}</div>`
            ).join('');
        });

        attachmentsListEl.addEventListener('click', (e) => {
            const removeBtn = e.target.closest('.remove-attachment-btn');
            if (removeBtn) {
                const index = parseInt(removeBtn.dataset.index);
                Crud.get(editingDocId, doc => {
                    doc.attachments.splice(index, 1);
                    Crud.save(doc, false);
                    openEditModal(editingDocId);
                });
            }
        });

        docForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const file = fileInput.files[0];
            const saveButton = e.submitter || docForm.querySelector('button[type="submit"]');
            
            const originalButtonHTML = saveButton.innerHTML;
            saveButton.disabled = true;
            saveButton.innerHTML = `<div class="ocr-loader mx-auto"></div>`;

            try {
                let fileHash = null;
                if (file) {
                    fileHash = await calculateFileHash(file);
                    const existingDoc = await checkForDuplicate(fileHash);
                    if (existingDoc && (!editingDocId || existingDoc.id != editingDocId)) {
                        showSnackbar(`Questo file esiste già: "${existingDoc.displayName}"`, true);
                        saveButton.disabled = false;
                        saveButton.innerHTML = originalButtonHTML;
                        return;
                    }
                }

                const processSubmit = async (baseDoc) => {
                    const newAttachments = await Promise.all(attachmentsToAdd.map(readFileAsDataURL));
                    baseDoc.attachments = [...(baseDoc.attachments || []), ...newAttachments];
                    const tags = docTagsHiddenInput.value.split(',').map(tag => tag.trim()).filter(tag => tag);
                    
                    const docData = {
                        ...baseDoc,
                        displayName: docForm['doc-name'].value,
                        year: parseInt(docForm['doc-year'].value),
                        category: docForm['doc-category'].value,
                        subcategory: docForm['doc-subcategory'].value,
                        tags: tags,
                        details: docForm['doc-details'].value,
                        uploadDate: editingDocId ? baseDoc.uploadDate : new Date().getTime(),
                    };
                    if (fileHash) docData.contentHash = fileHash;
                    await Crud.save(docData);
                };

                if (editingDocId) {
                    await new Promise((resolve, reject) => {
                        Crud.get(editingDocId, async (doc) => {
                            try {
                                if (!doc) return reject(new Error("Documento da modificare non trovato."));
                                let docToProcess = { ...doc };
                                if (file) {
                                    const { fileData, fileName, fileType } = await readFileAsDataURL(file);
                                    docToProcess.fileData = fileData;
                                    docToProcess.fileName = fileName;
                                    docToProcess.fileType = fileType;
                                }
                                await processSubmit(docToProcess);
                                resolve();
                            } catch (err) { reject(err); }
                        });
                    });
                } else {
                    if (!file) throw new Error("Seleziona un file principale.");
                    const { fileData, fileName, fileType } = await readFileAsDataURL(file);
                    const newDoc = { fileData, fileName, fileType, attachments: [] };
                    await processSubmit(newDoc);
                }
            } catch (error) {
                console.error("Errore durante il salvataggio del documento:", error);
                if (error.name !== 'ConstraintError') {
                    showSnackbar(error.message || "Errore nel salvataggio.", true);
                }
            } finally {
                saveButton.disabled = false;
                saveButton.innerHTML = originalButtonHTML;
            }
        });
        
        docListContainer.addEventListener('click', (e) => {
            const target = e.target.closest('.preview-btn, .edit-doc-btn, .attachment-link, .tag-link, .delete-doc-btn');
            if (!target) return;
            e.preventDefault();

            if (target.matches('.delete-doc-btn')) {
                docIdToDelete = parseInt(target.dataset.id);
                openModal(confirmDeleteModal);
            } else if (target.matches('.tag-link')) {
                activeTagFilter = target.dataset.tag;
                renderAll();
            } else if (target.matches('.attachment-link')) {
                showPreviewModal(target.dataset.docId, parseInt(target.dataset.attachmentIndex));
            } else if (target.matches('.edit-doc-btn')) {
                openEditModal(target.dataset.id);
            } else if (target.matches('.preview-btn')) {
                showPreviewModal(target.dataset.id);
            }
        });

        docTagsInput.addEventListener('keydown', e => {
            if (e.key === ',' || e.key === 'Enter') {
                e.preventDefault();
                addTag(docTagsInput.value);
                docTagsInput.value = '';
            }
        });
        selectedTagsContainer.addEventListener('click', e => {
            const removeBtn = e.target.closest('.remove-tag-btn');
            if (removeBtn) {
                currentTagsSet.delete(removeBtn.dataset.tag);
                updateTagsUI();
            } else {
                docTagsInput.focus();
            }
        });
        availableTagsContainer.addEventListener('click', e => {
            const addBtn = e.target.closest('.add-tag-btn');
            if (addBtn) addTag(addBtn.dataset.tag);
        });
        categoryInput.addEventListener('input', (e) => updateCategoryScopedTags(e.target.value));

        closePreviewBtn.addEventListener('click', () => closeModal(previewModal));
        
        printBtn.addEventListener('click', () => {
            const contentEl = previewContent.querySelector('canvas, img');
            if (contentEl) {
                const dataUrl = contentEl.tagName === 'CANVAS' ? contentEl.toDataURL('image/png') : contentEl.src;
                const printWindow = window.open('', '_blank');
                printWindow.document.write(`<html><body style="text-align:center;"><img src="${dataUrl}" style="max-width:100%;" onload="window.print();window.close();"></body></html>`);
                printWindow.document.close();
                printWindow.focus();
            } else {
                 showSnackbar("Stampa non disponibile per questo file.", true);
            }
        });

        editPreviewBtn.addEventListener('click', () => {
            if (currentPreviewDoc) {
                closeModal(previewModal);
                openEditModal(currentPreviewDoc.id);
            }
        });
        deletePreviewBtn.addEventListener('click', () => {
            if (currentPreviewDoc) {
                docIdToDelete = currentPreviewDoc.id;
                openModal(confirmDeleteModal);
            }
        });
        downloadBtn.addEventListener('click', () => {
            if(currentPreviewDoc){
                const a = document.createElement('a');
                const currentAttachmentIndex = parseInt(previewAttachmentsBar.querySelector('.bg-blue-600')?.dataset.index ?? -1);
                let fileToDownload = (currentAttachmentIndex === -1) 
                    ? { data: currentPreviewDoc.fileData, name: currentPreviewDoc.fileName }
                    : { data: currentPreviewDoc.attachments[currentAttachmentIndex].fileData, name: currentPreviewDoc.attachments[currentAttachmentIndex].fileName };
                a.href = fileToDownload.data;
                a.download = fileToDownload.name;
                a.click();
            }
        });
        previewAttachmentsBar.addEventListener('click', (e) => {
            const btn = e.target.closest('.attachment-preview-btn');
            if (btn) showPreviewModal(currentPreviewDoc.id, parseInt(btn.dataset.index));
        });
        
        cancelDeleteBtn.addEventListener('click', () => {
            docIdToDelete = null;
            closeModal(confirmDeleteModal);
        });
        confirmDeleteBtn.addEventListener('click', () => {
            if (docIdToDelete) {
                Crud.delete(docIdToDelete);
                docIdToDelete = null;
                closeModal(confirmDeleteModal);
            }
        });

        exportBtn.addEventListener('click', () => {
            Crud.getAll(async (docs) => {
                if (docs.length === 0) return showSnackbar("Nessun documento da esportare.");
                showSnackbar("Creazione del backup in corso...");
                try {
                    const zip = new JSZip();
                    const metadata = [];
                    for (const doc of docs) {
                        const docMetadata = { ...doc };
                        const mainFileName = `${doc.id}-${doc.fileName.replace(/[^a-zA-Z0-9.\-_]/g, '_')}`;
                        docMetadata.filePath = `files/${mainFileName}`;
                        zip.file(docMetadata.filePath, dataURLtoBlob(doc.fileData));
                        delete docMetadata.fileData;

                        if (doc.attachments && doc.attachments.length > 0) {
                            docMetadata.attachments = doc.attachments.map((att, i) => {
                                const attMetadata = { ...att };
                                const attFileName = `${doc.id}-att-${i}-${att.fileName.replace(/[^a-zA-Z0-9.\-_]/g, '_')}`;
                                attMetadata.filePath = `files/${attFileName}`;
                                zip.file(attMetadata.filePath, dataURLtoBlob(att.fileData));
                                delete attMetadata.fileData;
                                return attMetadata;
                            });
                        }
                        metadata.push(docMetadata);
                    }
                    zip.file("metadata.json", JSON.stringify(metadata, null, 2));
                    const zipBlob = await zip.generateAsync({ type: "blob" });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(zipBlob);
                    a.download = 'backup_documenti.zip';
                    a.click();
                    URL.revokeObjectURL(a.href);
                    showSnackbar("Esportazione completata.");
                } catch (err) {
                    showSnackbar("Errore durante l'esportazione.", true);
                    console.error(err);
                }
            });
        });

        importBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            showSnackbar("Importazione in corso...");
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const zip = await JSZip.loadAsync(e.target.result);
                    const metadataFile = zip.file("metadata.json");
                    if (!metadataFile) throw new Error("File metadata.json non trovato.");
                    const metadata = JSON.parse(await metadataFile.async("string"));
                    Crud.clear(async () => {
                        showSnackbar(`Importazione di ${metadata.length} documenti...`);
                        for (const docMeta of metadata) {
                             if (!zip.file(docMeta.filePath)) {
                                console.warn(`File ${docMeta.filePath} mancante per "${docMeta.displayName}".`);
                                continue;
                             }
                             const mainFileBlob = await zip.file(docMeta.filePath).async("blob");
                             docMeta.fileData = (await readFileAsDataURL(mainFileBlob)).fileData;
                             docMeta.fileType = mainFileBlob.type || getMimeTypeFromName(docMeta.fileName);
                             delete docMeta.filePath;
                             
                             if (docMeta.attachments) {
                                for(let attMeta of docMeta.attachments) {
                                    if (!zip.file(attMeta.filePath)) continue;
                                    const attFileBlob = await zip.file(attMeta.filePath).async("blob");
                                    attMeta.fileData = (await readFileAsDataURL(attFileBlob)).fileData;
                                    attMeta.fileType = attFileBlob.type || getMimeTypeFromName(attMeta.fileName);
                                    delete attMeta.filePath;
                                }
                             }
                             delete docMeta.id;
                             const fileForHash = new File([mainFileBlob], docMeta.fileName, { type: docMeta.fileType });
                             docMeta.contentHash = await calculateFileHash(fileForHash);
                             db.transaction("documents", "readwrite").objectStore("documents").put(docMeta);
                        }
                        showSnackbar('Importazione completata!');
                        renderAll();
                    });
                } catch (error) {
                    showSnackbar("Errore: il file di backup non è valido.", true);
                    console.error("Import error:", error);
                } finally {
                    importFileInput.value = ''; 
                }
            };
            reader.readAsArrayBuffer(file);
        });

        searchInput.addEventListener('input', renderDocuments);
        sortSelect.addEventListener('change', renderDocuments);
        itemsPerPageSelect.addEventListener('change', (e) => {
            itemsPerPage = parseInt(e.target.value, 10);
            renderDocuments();
        });
        loadMoreBtn.addEventListener('click', () => {
            currentPage++;
            displayCurrentPage(true);
        });

        viewListBtn.addEventListener('click', () => setView('list'));
        viewGridBtn.addEventListener('click', () => setView('grid'));

        fieldsToHighlight.forEach(field => {
            const removeHighlight = () => field.classList.remove('highlight-suggestion');
            field.addEventListener('input', removeHighlight);
            field.addEventListener('focus', removeHighlight);
        });

        const savedTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        applyTheme(savedTheme);
        updateViewButtons(currentView);
        initDB();
        lucide.createIcons();
    }

    window.addEventListener('load', () => {
        const requiredLibs = ['pdfjsLib', 'Tesseract', 'JSZip', 'lucide'];
        const maxRetries = 20;
        let retries = 0;
        const checkInterval = setInterval(() => {
            const missingLibs = requiredLibs.filter(lib => typeof window[lib] === 'undefined' || window[lib] === null);
            if (missingLibs.length === 0) {
                clearInterval(checkInterval);
                initializeApp();
            } else {
                retries++;
                if (retries > maxRetries) {
                    clearInterval(checkInterval);
                    document.getElementById('missing-libs-list').textContent = `Dettagli: ${missingLibs.join(', ')} non trovate.`;
                    document.getElementById('load-error-modal').classList.remove('hidden');
                    if (window.lucide) lucide.createIcons();
                    document.getElementById('reload-page-btn').onclick = () => window.location.reload();
                }
            }
        }, 500);
    });
    </script>
    
    <!-- ================================================================= -->
    <!-- SEZIONE REVISIONATA: Logica per Service Worker e Installazione PWA -->
    <!-- ================================================================= -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        
        let deferredPrompt;
        const installBtn = document.getElementById('installBtn');

        const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
        if (isStandalone) {
             console.log("App in esecuzione in modalità standalone, pulsante di installazione nascosto.");
             if(installBtn) installBtn.style.display = 'none';
        } else {
            console.log("App in esecuzione nel browser, pronto per l'installazione.");
        }
        
        window.addEventListener('beforeinstallprompt', (e) => {
            if (isStandalone) return;
            console.log('Evento "beforeinstallprompt" intercettato.');
            e.preventDefault();
            deferredPrompt = e;
            if (installBtn) {
                console.log("Mostro il pulsante di installazione personalizzato.");
                installBtn.classList.remove('hidden');
            }
        });

        if (installBtn) {
            installBtn.addEventListener('click', async () => {
                if (deferredPrompt) {
                    console.log("L'utente ha cliccato, mostro il prompt di installazione.");
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`L'utente ha scelto: ${outcome}`);
                    deferredPrompt = null;
                    installBtn.classList.add('hidden');
                }
            });
        }
        
        window.addEventListener('appinstalled', () => {
            console.log('PWA installata con successo!');
            if (installBtn) installBtn.style.display = 'none';
            deferredPrompt = null;
            if(typeof showSnackbar === 'function') {
                showSnackbar('Applicazione installata con successo!');
            }
        });

        const swCode = `
            const CACHE_NAME = 'doc-manager-cache-v2';
            const URLS_TO_CACHE = [
                './',
                'https://cdn.tailwindcss.com',
                'https://cdn.jsdelivr.net/npm/lucide@0.378.0/dist/umd/lucide.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js',
                'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js',
                'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap'
            ];

            self.addEventListener('install', event => {
                console.log('Service Worker: Installazione...');
                event.waitUntil(
                    caches.open(CACHE_NAME)
                        .then(cache => {
                            console.log('Service Worker: Caching delle risorse...');
                            return cache.addAll(URLS_TO_CACHE);
                        })
                        .then(() => self.skipWaiting())
                );
            });

            self.addEventListener('activate', event => {
                console.log('Service Worker: Attivazione...');
                event.waitUntil(
                    caches.keys().then(cacheNames => {
                        return Promise.all(
                            cacheNames.map(cache => {
                                if (cache !== CACHE_NAME) {
                                    console.log('Service Worker: Rimozione vecchia cache:', cache);
                                    return caches.delete(cache);
                                }
                            })
                        );
                    }).then(() => self.clients.claim())
                );
            });

            self.addEventListener('fetch', event => {
                event.respondWith(
                    caches.match(event.request)
                        .then(response => {
                            return response || fetch(event.request);
                        })
                );
            });
        `;

        if ('serviceWorker' in navigator) {
            try {
                const swBlob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(swBlob);
                navigator.serviceWorker.register(swUrl, { scope: './' })
                    .then(registration => {
                        console.log('Service Worker registrato con successo. Scope:', registration.scope);
                    });
            } catch (error) {
                 console.error('Registrazione del Service Worker fallita:', error);
            }
        }
    });
    </script>
</body>
</html>
