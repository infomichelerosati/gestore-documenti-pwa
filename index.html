<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archivia i tuoi Documenti</title>
    
    <!-- Tailwind CSS per uno stile moderno e responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = { darkMode: 'class' }
    </script>
    
    <!-- Icone Lucide -->
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.378.0/dist/umd/lucide.min.js"></script>

    <!-- Librerie Esterne -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/docx-preview@0.1.20/dist/docx-preview.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- Font Inter da Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Meta tag per la PWA -->
    <meta name="theme-color" content="#317EFB"/>
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/317EFB/ffffff?text=Docs">
    <link rel="manifest" href="manifest.json"> <!-- Collegamento al file manifest -->

    <style>
        html.dark { color-scheme: dark; }
        body { font-family: 'Inter', sans-serif; overflow-x: hidden; }
        .sidebar { transition: transform 0.3s ease-in-out; }
        .sidebar-overlay { transition: opacity 0.3s ease-in-out; }
        .details-content { overflow: hidden; transition: max-height 0.3s ease-out; }
        details[open] .details-content { max-height: 1000px; }
        details .summary-arrow { transition: transform 0.2s; }
        details[open] .summary-arrow { transform: rotate(90deg); }
        .filter-tree ul { padding-left: 1rem; }
        .filter-tree summary, .filter-tree li { cursor: pointer; }
        .filter-tree summary.active > span, .filter-tree li.active > span { font-weight: bold; color: #3b82f6; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        html.dark ::-webkit-scrollbar-track { background: #2d3748; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px;}
        html.dark ::-webkit-scrollbar-thumb { background: #555; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        html.dark ::-webkit-scrollbar-thumb:hover { background: #444; }
        .ocr-loader {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .highlight-suggestion { animation: pulse-bg 2s infinite; }
        @keyframes pulse-bg { 0% { background-color: inherit; } 50% { background-color: rgba(59, 130, 246, 0.1); } 100% { background-color: inherit; } }
        .powered-by {
            position: fixed; top: 4px; left: 50%; font-size: 0.65rem; font-weight: 500; z-index: 50;
            pointer-events: none; animation: color-cycle 18s linear infinite, pulse-light 4s ease-in-out infinite;
            text-shadow: 0 0 3px rgba(0,0,0,0.4); background: transparent;
        }
        @keyframes color-cycle { 0% { color: #ff8a80; } 16% { color: #ffcf7d; } 33% { color: #b9f6ca; } 50% { color: #84ffff; } 67% { color: #8c9eff; } 83% { color: #f8bbd0; } 100% { color: #ff8a80; } }
        @keyframes pulse-light { 0%, 100% { transform: translateX(-50%) scale(1); opacity: 0.9; } 50% { transform: translateX(-50%) scale(1.05); opacity: 1; } }
        .excel-preview-container { width: 100%; height: 100%; overflow: auto; background-color: white; padding: 1rem; border-radius: 8px; }
        .excel-preview-container table { border-collapse: collapse; width: 100%; font-size: 0.8rem; }
        .excel-preview-container th, .excel-preview-container td { border: 1px solid #ddd; padding: 4px 8px; text-align: left; color: #333; }
        .excel-preview-container th { background-color: #f2f2f2; font-weight: bold; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200">
    <div class="powered-by">Powered By Michele Rosati</div>

    <!-- Sidebar a scomparsa per i filtri -->
    <aside id="sidebar" class="sidebar fixed top-0 left-0 w-72 h-full bg-white dark:bg-gray-800 shadow-lg z-30 transform -translate-x-full flex flex-col">
        <div class="p-4 flex-grow overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Filtra Documenti</h2>
                <button id="close-sidebar-btn" class="p-1 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            
            <div class="mb-4 bg-gray-50 dark:bg-gray-700/50 p-3 rounded-lg text-sm space-y-2">
                <h3 class="font-semibold text-gray-800 dark:text-gray-200">Statistiche Archivio</h3>
                <div class="flex justify-between items-center">
                    <span class="text-gray-600 dark:text-gray-400">Documenti totali:</span>
                    <span id="stats-total-docs" class="font-bold">0</span>
                </div>
                <div class="flex justify-between items-center">
                    <span class="text-gray-600 dark:text-gray-400">Spazio occupato:</span>
                    <span id="stats-total-size" class="font-bold">0 MB</span>
                </div>
            </div>

            <button id="reset-filter-btn" class="w-full text-center text-sm mb-4 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 p-2 rounded-md">Mostra tutti</button>
            
            <h3 class="text-lg font-semibold mb-2 mt-4">Categorie</h3>
            <div id="filter-tree" class="filter-tree"></div>

        </div>
        <div class="p-4 border-t border-gray-200 dark:border-gray-700">
            <h2 class="text-lg font-semibold mb-3">Impostazioni</h2>
            <div class="space-y-2">
                <button id="export-data-btn" class="w-full flex items-center gap-2 p-2 rounded-md text-sm text-left bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600">
                    <i data-lucide="download" class="w-4 h-4"></i>
                    <span>Esporta Dati</span>
                </button>
                <button id="import-data-btn" class="w-full flex items-center gap-2 p-2 rounded-md text-sm text-left bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600">
                     <i data-lucide="upload" class="w-4 h-4"></i>
                    <span>Importa Dati</span>
                </button>
                <input type="file" id="import-file-input" class="hidden" accept=".zip">
            </div>
        </div>
    </aside>
    <div id="sidebar-overlay" class="sidebar-overlay fixed inset-0 bg-black bg-opacity-50 z-20 hidden"></div>

    <!-- Contenuto Principale -->
    <div class="container mx-auto max-w-6xl h-screen flex flex-col">
        <div class="flex-shrink-0 bg-gray-100 dark:bg-gray-900 z-10 sticky top-0 pt-4 px-4">
            <header class="flex justify-between items-center mb-6">
                <div class="flex items-center gap-4">
                    <button id="menu-btn" class="p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700">
                        <i data-lucide="menu" class="w-6 h-6"></i>
                    </button>
                    <h1 class="text-3xl font-bold text-blue-600 dark:text-blue-400">Gestore Documenti</h1>
                </div>
                <div class="flex items-center gap-2">
                    <button id="theme-toggle-btn" class="p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700">
                        <i data-lucide="sun" class="w-6 h-6 block dark:hidden"></i>
                        <i data-lucide="moon" class="w-6 h-6 hidden dark:block"></i>
                    </button>
                    <button id="fullscreen-btn" class="p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700">
                        <i data-lucide="maximize" class="w-6 h-6 block"></i>
                        <i data-lucide="minimize" class="w-6 h-6 hidden"></i>
                    </button>
                    <button id="installBtn" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                        Installa App
                    </button>
                </div>
            </header>

            <div class="mb-6 flex flex-col sm:flex-row gap-4">
                <div class="relative flex-grow">
                    <input type="search" id="search-input" placeholder="Cerca in nome, tag, dettagli..." class="w-full p-3 pl-10 text-sm border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none dark:placeholder-gray-400">
                    <div class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                        <i data-lucide="search" class="w-5 h-5 text-gray-400"></i>
                    </div>
                </div>
                <div class="flex items-center gap-2 flex-shrink-0">
                    <select id="sort-select" class="w-full sm:w-auto p-3 text-sm border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                        <option value="date_desc">Più Recenti</option>
                        <option value="date_asc">Meno Recenti</option>
                        <option value="name_asc">Nome (A-Z)</option>
                        <option value="name_desc">Nome (Z-A)</option>
                        <option value="year_desc">Anno (Decrescente)</option>
                        <option value="year_asc">Anno (Crescente)</option>
                    </select>
                    <select id="items-per-page-select" class="w-full sm:w-auto p-3 text-sm border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                        <option value="10">10 per pagina</option>
                        <option value="20">20 per pagina</option>
                        <option value="50">50 per pagina</option>
                        <option value="99999">Mostra tutti</option>
                    </select>
                     <div class="flex rounded-lg shadow-sm bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700">
                        <button id="view-list-btn" class="p-3 text-blue-500 bg-blue-50 dark:bg-gray-700 rounded-l-md" title="Vista a Lista">
                            <i data-lucide="list" class="w-5 h-5"></i>
                        </button>
                        <button id="view-grid-btn" class="p-3 text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700" title="Vista a Griglia">
                            <i data-lucide="layout-grid" class="w-5 h-5"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="scrollable-content" class="flex-grow overflow-y-auto pb-24 px-4">
            <main id="document-list-container"></main>
            
            <div id="pagination-container" class="text-center py-8">
                <button id="load-more-btn" class="hidden bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 font-bold py-2 px-5 rounded-lg">Carica altri</button>
            </div>

            <div id="empty-state" class="hidden text-center py-16">
                <i data-lucide="folder-open" class="mx-auto h-12 w-12 text-gray-400"></i>
                <h3 class="mt-2 text-sm font-semibold text-gray-900 dark:text-gray-100">Nessun documento</h3>
                <p class="mt-1 text-sm text-gray-500">Aggiungi un documento o cambia i filtri di ricerca.</p>
            </div>
        </div>
    </div>

    <button id="add-doc-btn" class="fixed bottom-6 right-6 bg-blue-600 hover:bg-blue-700 text-white p-4 rounded-full shadow-lg transition-transform transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 z-20">
        <i data-lucide="plus" class="w-6 h-6"></i>
    </button>
    
    <div id="doc-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center p-4 z-40">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md p-6 max-h-[90vh] overflow-y-auto">
            <h2 id="modal-title" class="text-2xl font-bold mb-4">Aggiungi Documento</h2>
            <form id="doc-form">
                <input type="hidden" id="doc-id">
                <div class="mb-4">
                    <label for="doc-file" class="block text-sm font-medium mb-1">File Principale</label>
                    <div class="flex items-center gap-2">
                        <input type="file" id="doc-file" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 dark:file:bg-gray-700 file:text-blue-700 dark:file:text-blue-300 hover:file:bg-blue-100 dark:hover:file:bg-gray-600"/>
                        <button type="button" id="ocr-btn" title="Analizza documento con OCR (immagini o PDF)" class="flex-shrink-0 p-2 rounded-full bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed">
                            <i data-lucide="scan-text" class="w-5 h-5"></i>
                        </button>
                    </div>
                    <div id="ocr-status" class="text-xs text-gray-500 mt-1 flex items-center gap-1.5"></div>
                    <div id="current-file-name" class="text-xs text-gray-500 mt-1"></div>
                </div>
                
                <div id="file-preview-container" class="mb-4 hidden">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Anteprima</label>
                    <div id="file-preview" class="mt-1 p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-gray-50 dark:bg-gray-700 max-h-48 overflow-y-auto flex justify-center items-center"></div>
                </div>
                
                <div class="mb-4">
                    <label for="doc-attachments" class="block text-sm font-medium mb-1">Allega altri file</label>
                    <input type="file" id="doc-attachments" multiple class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 dark:file:bg-gray-700 file:text-blue-700 dark:file:text-blue-300 hover:file:bg-blue-100 dark:hover:file:bg-gray-600"/>
                    <div id="attachments-list" class="mt-2 space-y-1 text-sm"></div>
                </div>

                <div class="mb-4"><label for="doc-name" class="block text-sm font-medium mb-1">Nome Visualizzato</label><input type="text" id="doc-name" required class="mt-1 block w-full p-2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm dark:placeholder-gray-400"></div>
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div><label for="doc-year" class="block text-sm font-medium mb-1">Anno</label><input type="number" id="doc-year" placeholder="Es. 2025" required class="mt-1 block w-full p-2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm dark:placeholder-gray-400"></div>
                    <div><label for="doc-category" class="block text-sm font-medium mb-1">Categoria</label><input list="category-suggestions" type="text" id="doc-category" placeholder="Es. Bollette" required class="mt-1 block w-full p-2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm dark:placeholder-gray-400"></div>
                </div>
                <div class="mb-4"><label for="doc-subcategory" class="block text-sm font-medium mb-1">Sottocategoria</label><input list="subcategory-suggestions" type="text" id="doc-subcategory" placeholder="Es. Gas" required class="mt-1 block w-full p-2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm dark:placeholder-gray-400"></div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-1">Tag</label>
                    <div id="selected-tags-container" class="flex flex-wrap gap-2 items-center p-2 rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 min-h-[42px] cursor-text">
                        <input type="text" id="doc-tags-input" placeholder="Aggiungi tag..." class="flex-grow bg-transparent outline-none border-none p-0 text-sm">
                    </div>
                    <input type="hidden" id="doc-tags" name="doc-tags">
                    <div id="available-tags-section" class="mt-2 hidden">
                        <label class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Tag suggeriti per questa categoria:</label>
                        <div id="available-tags-container" class="flex flex-wrap gap-1 text-xs"></div>
                    </div>
                </div>

                <div class="mb-6"><label for="doc-details" class="block text-sm font-medium mb-1">Dettagli</label><textarea id="doc-details" rows="3" placeholder="Aggiungi note qui..." class="mt-1 block w-full p-2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm dark:placeholder-gray-400"></textarea></div>
                <div class="flex justify-end space-x-3">
                    <button type="button" id="cancel-btn" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500 font-bold py-2 px-4 rounded-lg">Annulla</button>
                    <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Salva</button>
                </div>
            </form>
            <datalist id="category-suggestions"></datalist>
            <datalist id="subcategory-suggestions"></datalist>
            <datalist id="tags-suggestions"></datalist>
        </div>
    </div>

    <div id="preview-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex flex-col p-4 z-50">
        <div class="flex-shrink-0 flex justify-between items-center text-white mb-4">
            <h2 id="preview-title" class="text-xl font-bold">Anteprima</h2>
            <div class="flex items-center gap-4">
                <button id="print-btn" title="Stampa"><i data-lucide="printer" class="w-6 h-6"></i></button>
                <button id="download-btn" title="Scarica"><i data-lucide="download" class="w-6 h-6"></i></button>
                <button id="edit-preview-btn" title="Modifica"><i data-lucide="edit-2" class="w-6 h-6"></i></button>
                <button id="delete-preview-btn" title="Elimina"><i data-lucide="trash-2" class="w-6 h-6 text-red-400"></i></button>
                <button id="close-preview-btn" title="Chiudi"><i data-lucide="x" class="w-8 h-8"></i></button>
            </div>
        </div>
        <div id="preview-content" class="flex-grow flex items-center justify-center overflow-auto relative"></div>
        <div id="preview-attachments-bar" class="flex-shrink-0 bg-black bg-opacity-50 p-2 text-white text-center overflow-x-auto whitespace-nowrap hidden"></div>
    </div>

    <div id="confirm-delete-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-sm p-6">
            <h2 class="text-lg font-bold mb-2">Conferma Eliminazione</h2>
            <p class="text-sm text-gray-600 dark:text-gray-300 mb-4">Sei sicuro di voler eliminare questo documento? L'azione è irreversibile.</p>
            <div class="flex justify-end space-x-3">
                <button id="cancel-delete-btn" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500 font-bold py-2 px-4 rounded-lg">Annulla</button>
                <button id="confirm-delete-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Elimina</button>
            </div>
        </div>
    </div>
    
    <div id="snackbar" class="fixed bottom-6 left-1/2 -translate-x-1/2 bg-gray-800 text-white py-2 px-5 rounded-lg shadow-lg transition-opacity duration-300 opacity-0 z-50"></div>

    <div id="load-error-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex flex-col items-center justify-center p-4 z-50 text-white text-center">
        <i data-lucide="server-crash" class="w-24 h-24 text-red-400 mb-4"></i>
        <h2 class="text-2xl font-bold mb-2">Errore Critico</h2>
        <p class="mb-6 max-w-md">Impossibile caricare alcune risorse fondamentali per il funzionamento dell'applicazione. Controlla la tua connessione a internet.</p>
        <p id="missing-libs-list" class="text-sm text-gray-400 mb-6"></p>
        <button id="reload-page-btn" class="bg-blue-600 hover:bg-blue-700 font-bold py-2 px-6 rounded-lg">Ricarica Pagina</button>
    </div>

    <!-- NUOVO: Modal di Caricamento per l'Importazione -->
    <div id="import-loading-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex flex-col items-center justify-center p-4 z-50 text-white text-center">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl w-full max-w-sm">
            <h2 class="text-xl font-bold mb-4">Importazione in corso...</h2>
            <p id="import-progress-text" class="text-sm text-gray-300 mb-4 h-10">Preparazione dell'archivio...</p>
            <div class="w-full bg-gray-600 rounded-full h-4">
                <div id="import-progress-bar" class="bg-blue-600 h-4 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <p id="import-progress-percentage" class="mt-2 text-lg font-semibold">0%</p>
        </div>
    </div>

    <!-- ===================================================================== -->
    <!-- LOGICA JAVASCRIPT CORRETTA PER PWA                  -->
    <!-- ===================================================================== -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            if ('serviceWorker' in navigator) {
                // Registra il Service Worker
                navigator.serviceWorker.register('service-worker.js', { scope: './' })
                    .then(registration => {
                        console.log('PWA: Service Worker registrato con successo. Scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('PWA: Registrazione del Service Worker fallita:', error);
                    });
            }
        });
        
        function initializeApp() {
            console.log("App inizializzata.");
        
            if (window.pdfjsLib) {
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;
            } else {
                console.warn("Attenzione: libreria PDF.js non caricata.");
            }
            
            const docListContainer = document.getElementById('document-list-container');
            const emptyStateEl = document.getElementById('empty-state');
            const searchInput = document.getElementById('search-input');
            const sortSelect = document.getElementById('sort-select');
            const addDocBtn = document.getElementById('add-doc-btn');
            let currentFilter = {};
            let activeTagFilter = null;
            let db;
            let docIdToDelete = null;
            let editingDocId = null;
            let attachmentsToAdd = [];
            let currentPreviewDoc = null;
            let currentView = localStorage.getItem('doc-view') || 'list';
            let fullFilteredDocs = [];
            let currentPage = 1;
            let itemsPerPage = 10;

            const docModal = document.getElementById('doc-modal');
            const docForm = document.getElementById('doc-form');
            const modalTitle = document.getElementById('modal-title');
            const docIdInput = docForm['doc-id'];
            const cancelBtn = document.getElementById('cancel-btn');
            const fileInput = docForm['doc-file'];
            const ocrBtn = document.getElementById('ocr-btn');
            const ocrStatusEl = document.getElementById('ocr-status');
            const currentFileNameEl = document.getElementById('current-file-name');
            const attachmentsInput = docForm['doc-attachments'];
            const attachmentsListEl = document.getElementById('attachments-list');
            const categorySuggestions = document.getElementById('category-suggestions');
            const subcategorySuggestions = document.getElementById('subcategory-suggestions');
            const tagsSuggestions = document.getElementById('tags-suggestions');
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            const menuBtn = document.getElementById('menu-btn');
            const filterTreeEl = document.getElementById('filter-tree');
            const closeSidebarBtn = document.getElementById('close-sidebar-btn');
            const resetFilterBtn = document.getElementById('reset-filter-btn');
            const previewModal = document.getElementById('preview-modal');
            const previewTitle = document.getElementById('preview-title');
            const previewContent = document.getElementById('preview-content');
            const previewAttachmentsBar = document.getElementById('preview-attachments-bar');
            const closePreviewBtn = document.getElementById('close-preview-btn');
            const printBtn = document.getElementById('print-btn');
            const downloadBtn = document.getElementById('download-btn');
            const editPreviewBtn = document.getElementById('edit-preview-btn');
            const deletePreviewBtn = document.getElementById('delete-preview-btn');
            const confirmDeleteModal = document.getElementById('confirm-delete-modal');
            const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
            const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
            const exportBtn = document.getElementById('export-data-btn');
            const importBtn = document.getElementById('import-data-btn');
            const importFileInput = document.getElementById('import-file-input');
            const themeToggleBtn = document.getElementById('theme-toggle-btn');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const viewListBtn = document.getElementById('view-list-btn');
            const viewGridBtn = document.getElementById('view-grid-btn');
            const statsTotalDocs = document.getElementById('stats-total-docs');
            const statsTotalSize = document.getElementById('stats-total-size');
            const itemsPerPageSelect = document.getElementById('items-per-page-select');
            const loadMoreBtn = document.getElementById('load-more-btn');
            const loadErrorModal = document.getElementById('load-error-modal');
            const fieldsToHighlight = [
                docForm['doc-name'], docForm['doc-year'], docForm['doc-category'],
                docForm['doc-subcategory'], docForm['doc-details']
            ];
            
            // Variabili per la nuova modal di caricamento
            const importLoadingModal = document.getElementById('import-loading-modal');
            const importProgressText = document.getElementById('import-progress-text');
            const importProgressBar = document.getElementById('import-progress-bar');
            const importProgressPercentage = document.getElementById('import-progress-percentage');

            const selectedTagsContainer = document.getElementById('selected-tags-container');
            const docTagsInput = document.getElementById('doc-tags-input');
            const availableTagsSection = document.getElementById('available-tags-section');
            const availableTagsContainer = document.getElementById('available-tags-container');
            const docTagsHiddenInput = document.getElementById('doc-tags');
            const categoryInput = docForm['doc-category'];

            let currentTagsSet = new Set();
            let allKnownTags = new Set();
            let categoryScopedTags = new Set();
            
            let deferredPrompt;
            const installBtn = document.getElementById('installBtn');
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;

            if (isStandalone) {
                console.log("PWA DEBUG: L'app è già in modalità standalone.");
                if(installBtn) installBtn.style.display = 'none';
            } else {
                console.log("PWA DEBUG: L'app è in esecuzione nel browser, in attesa dei criteri di installabilità.");
                window.addEventListener('beforeinstallprompt', (e) => {
                    console.log('PWA DEBUG: Evento "beforeinstallprompt" intercettato! L\'app è installabile.');
                    e.preventDefault();
                    deferredPrompt = e;
                    if (installBtn) {
                        installBtn.classList.remove('hidden');
                    }
                });
            }

            if (installBtn) {
                installBtn.addEventListener('click', async () => {
                    if (deferredPrompt) {
                        deferredPrompt.prompt();
                        const { outcome } = await deferredPrompt.userChoice;
                        if (outcome === 'accepted') {
                            installBtn.classList.add('hidden');
                        }
                        deferredPrompt = null;
                    }
                });
            }
            
            window.addEventListener('appinstalled', () => {
                console.log('PWA DEBUG: Evento "appinstalled" ricevuto.');
                if (installBtn) installBtn.style.display = 'none';
                deferredPrompt = null;
                showSnackbar('Applicazione installata con successo!');
            });
            

            function getPdfjsLib() {
                if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
                    return window.pdfjsLib;
                }
                console.error("Libreria PDF.js non caricata.");
                showSnackbar("Errore: la libreria per i PDF non è stata caricata.");
                return null;
            }

            function initDB() {
                const request = indexedDB.open("DocumentManagerDB_v3", 2);
                request.onerror = e => console.error("DB Error:", e.target.errorCode);
                request.onupgradeneeded = e => {
                    db = e.target.result;
                    let store;
                    if (!db.objectStoreNames.contains("documents")) {
                        store = db.createObjectStore("documents", { keyPath: "id", autoIncrement: true });
                        store.createIndex("year_category_subcategory", ["year", "category", "subcategory"], { unique: false });
                    } else {
                        store = e.target.transaction.objectStore("documents");
                    }
                    if (!store.indexNames.contains("contentHash")) {
                        store.createIndex("contentHash", "contentHash", { unique: true });
                    }
                };
                request.onsuccess = e => {
                    db = e.target.result;
                    renderAll();
                };
            }

            function renderAll() {
                renderDocuments();
                renderFilterTree();
                updateDatalists();
                renderStats();
            }
            
            const Crud = {
                save: (doc, showNotification = true) => {
                    return new Promise((resolve, reject) => {
                        const tx = db.transaction("documents", "readwrite");
                        tx.oncomplete = () => {
                            if (showNotification) {
                                showSnackbar("Documento salvato!");
                                closeModal(docModal);
                                renderAll();
                            }
                            resolve();
                        };
                        tx.onerror = (event) => {
                            console.error("Errore transazione DB:", event.target.error);
                            if (event.target.error.name === 'ConstraintError') {
                                showSnackbar("Errore: un file con questo stesso contenuto esiste già.", true);
                            }
                            reject(event.target.error);
                        };
                        tx.objectStore("documents").put(doc);
                    });
                },
                delete: (docId) => {
                    const tx = db.transaction("documents", "readwrite");
                    tx.objectStore("documents").delete(docId);
                    tx.oncomplete = () => {
                        showSnackbar("Documento eliminato.");
                        currentPreviewDoc = null;
                        renderAll();
                        if(!previewModal.classList.contains('hidden')) closeModal(previewModal);
                    };
                },
                get: (docId, callback) => {
                    db.transaction("documents").objectStore("documents").get(parseInt(docId)).onsuccess = e => callback(e.target.result);
                },
                getAll: (callback) => {
                    db.transaction("documents").objectStore("documents").getAll().onsuccess = e => callback(e.target.result);
                },
                clear: (callback) => {
                    const tx = db.transaction("documents", "readwrite");
                    tx.objectStore("documents").clear();
                    tx.oncomplete = callback;
                }
            };
            
            function calculateSimilarity(s1, s2) {
                let longer = s1, shorter = s2;
                if (s1.length < s2.length) { longer = s2; shorter = s1; }
                const longerLength = longer.length;
                if (longerLength === 0) return 1.0;
                return (longerLength - levenshteinDistance(longer, shorter)) / parseFloat(longerLength);
            }

            function levenshteinDistance(s1, s2) {
                s1 = s1.toLowerCase(); s2 = s2.toLowerCase();
                const costs = [];
                for (let i = 0; i <= s1.length; i++) {
                    let lastValue = i;
                    for (let j = 0; j <= s2.length; j++) {
                        if (i == 0) costs[j] = j;
                        else {
                            if (j > 0) {
                                let newValue = costs[j - 1];
                                if (s1.charAt(i - 1) != s2.charAt(j - 1)) newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                                costs[j - 1] = lastValue;
                                lastValue = newValue;
                            }
                        }
                    }
                    if (i > 0) costs[s2.length] = lastValue;
                }
                return costs[s2.length];
            }
            
            function findBestMatchForWord(word, wordList) {
                let bestScore = 0;
                for (const ocrWord of wordList) {
                    const score = calculateSimilarity(word, ocrWord);
                    if (score > bestScore) bestScore = score;
                }
                return bestScore;
            }

            function getMimeTypeFromName(fileName) {
                if (!fileName || !fileName.includes('.')) return 'application/octet-stream';
                const extension = fileName.split('.').pop().toLowerCase();
                switch (extension) {
                    case 'jpg': case 'jpeg': return 'image/jpeg';
                    case 'png': return 'image/png';
                    case 'gif': return 'image/gif';
                    case 'webp': return 'image/webp';
                    case 'svg': return 'image/svg+xml';
                    case 'pdf': return 'application/pdf';
                    case 'docx': return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
                    case 'xlsx': return 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
                    default: return 'application/octet-stream';
                }
            }

            function getExistingCategoriesAndSubcategories() {
                return new Promise(resolve => {
                    Crud.getAll(docs => {
                        const existingCategories = new Set(), existingSubcategories = new Set();
                        docs.forEach(doc => {
                            if (doc.category) existingCategories.add(doc.category);
                            if (doc.subcategory) existingSubcategories.add(doc.subcategory);
                        });
                        resolve({ existingCategories, existingSubcategories });
                    });
                });
            }

            const dataURLtoBlob = (dataurl) => {
                if (!dataurl || !dataurl.includes(',')) return null;
                const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]);
                let n = bstr.length; const u8arr = new Uint8Array(n);
                while(n--) u8arr[n] = bstr.charCodeAt(n);
                return new Blob([u8arr], {type:mime});
            }

            const readFileAsDataURL = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve({
                        fileData: reader.result, fileName: file.name,
                        fileType: file.type || getMimeTypeFromName(file.name)
                    });
                    reader.onerror = () => reject(new Error(`Impossibile leggere il file "${file.name}"`));
                    reader.readAsDataURL(file);
                });
            };

            async function calculateFileHash(file) {
                const buffer = await file.arrayBuffer();
                const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            function checkForDuplicate(hash) {
                return new Promise((resolve, reject) => {
                    if (!db) return resolve(null);
                    const index = db.transaction("documents", "readonly").objectStore("documents").index("contentHash");
                    const request = index.get(hash);
                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = (e) => reject(e.target.error);
                });
            }

            const getBase64Size = (base64) => {
                if (!base64 || typeof base64 !== 'string') return 0;
                return 4 * Math.ceil((base64.length - base64.indexOf(',')) / 3) * 0.5624896334383812;
            };

            const formatBytes = (bytes, decimals = 2) => {
                if (bytes === 0) return '0 Bytes';
                const k = 1024, dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }

            const highlightField = (element) => {
                if (element && element.value) element.classList.add('highlight-suggestion');
            };

            const clearAllHighlights = () => fieldsToHighlight.forEach(f => f.classList.remove('highlight-suggestion'));

            function parseFilenameForMetadata(filename) {
                if (!filename) return;
                const nameWithoutExt = filename.substring(0, filename.lastIndexOf('.')) || filename;
                if (!docForm['doc-name'].value) {
                    docForm['doc-name'].value = nameWithoutExt.replace(/[-_]/g, ' ');
                    highlightField(docForm['doc-name']);
                }
                if (!docForm['doc-year'].value) {
                    const yearMatch = nameWithoutExt.match(/\b(19|20)\d{2}\b/);
                    if (yearMatch) {
                        docForm['doc-year'].value = yearMatch[0];
                        highlightField(docForm['doc-year']);
                    }
                }
                if (!docForm['doc-category'].value) {
                    const parts = nameWithoutExt.replace(/\b(19|20)\d{2}\b/, '').split(/[-_ ]+/).filter(p => p.toLowerCase() !== 'fattura' && p.toLowerCase() !== 'bolletta');
                    if (parts.length > 0) {
                        docForm['doc-category'].value = parts[0];
                        highlightField(docForm['doc-category']);
                    }
                    if (parts.length > 1 && !docForm['doc-subcategory'].value) {
                        docForm['doc-subcategory'].value = parts[1];
                        highlightField(docForm['doc-subcategory']);
                    }
                }
            }
            
            async function runOCR() {
                const file = fileInput.files[0];
                if (!file || (!file.type.startsWith('image/') && file.type !== 'application/pdf')) {
                    return showSnackbar("Seleziona un file immagine o PDF per l'analisi OCR.");
                }
                ocrStatusEl.innerHTML = `<div class="ocr-loader"></div> <span>Inizializzazione OCR...</span>`;
                ocrBtn.disabled = true;
                const worker = await Tesseract.createWorker('ita', 1, {
                    logger: m => {
                        if (m.status === 'recognizing text') ocrStatusEl.innerHTML = `<div class="ocr-loader"></div> <span>Analisi in corso (${(m.progress * 100).toFixed(0)}%)...</span>`;
                        else if (m.status === 'loading language model') ocrStatusEl.innerHTML = `<div class="ocr-loader"></div> <span>Caricamento modello lingua...</span>`;
                    },
                });
                try {
                    let imageSource;
                    if (file.type.startsWith('image/')) imageSource = file;
                    else if (file.type === 'application/pdf') {
                        ocrStatusEl.innerHTML = `<div class="ocr-loader"></div> <span>Caricamento PDF...</span>`;
                        const pdfjsLib = getPdfjsLib(); 
                        if (!pdfjsLib) throw new Error("Libreria PDF non disponibile.");
                        const arrayBuffer = await file.arrayBuffer();
                        const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(arrayBuffer) }).promise;
                        const page = await pdf.getPage(1);
                        const viewport = page.getViewport({ scale: 2.0 });
                        const canvas = document.createElement('canvas');
                        canvas.height = viewport.height; canvas.width = viewport.width;
                        await page.render({ canvasContext: canvas.getContext('2d'), viewport: viewport }).promise;
                        imageSource = canvas;
                    }
                    const { data: { text } } = await worker.recognize(imageSource);
                    await parseOCRText(text);
                    ocrStatusEl.innerHTML = `<i data-lucide="check-circle" class="w-4 h-4 text-green-500"></i> <span>Analisi completata. Controlla i campi.</span>`;
                } catch (error) {
                    console.error("OCR Error:", error);
                    ocrStatusEl.innerHTML = `<i data-lucide="x-circle" class="w-4 h-4 text-red-500"></i> <span class="text-left">Errore durante l'analisi.</span>`;
                } finally {
                    await worker.terminate();
                    ocrBtn.disabled = false;
                    lucide.createIcons();
                }
            }

            async function parseOCRText(text) {
                if (!text) return;
                let detailsFound = false; 
                const setField = (element, value) => {
                    if (element && !element.value && value) {
                        element.value = value.trim();
                        highlightField(element);
                    }
                };
                const appendToDetails = (label, value) => {
                    if (value) {
                        detailsFound = true; 
                        const cleanLabel = label.trim(), cleanValue = value.trim();
                        const labelRegex = new RegExp(`^${cleanLabel}:|\\n${cleanLabel}:`, 'm');
                        if (!labelRegex.test(docForm['doc-details'].value)) {
                            docForm['doc-details'].value += (docForm['doc-details'].value ? '\n' : '') + `${cleanLabel}: ${cleanValue}`;
                            highlightField(docForm['doc-details']);
                        }
                    }
                };
                const addTagFromOCR = (tag) => {
                    if (tag && !currentTagsSet.has(tag.trim())) {
                        currentTagsSet.add(tag.trim());
                        updateTagsUI();
                        highlightField(selectedTagsContainer); 
                    }
                };
                const { existingCategories, existingSubcategories } = await getExistingCategoriesAndSubcategories();
                const sortedCategories = [...existingCategories].sort((a, b) => b.length - a.length);
                const sortedSubcategories = [...existingSubcategories].sort((a, b) => b.length - a.length);
                const ocrWords = text.toLowerCase().replace(/[.,/#!$%\^&*;:{}=\-_`~()]/g, "").split(/\s+/).filter(Boolean);
                const WORD_SIMILARITY_THRESHOLD = 0.8; 
                if (!docForm['doc-category'].value) {
                    for (const category of sortedCategories) {
                        const catWords = category.toLowerCase().split(' '); let allWordsFound = true;
                        for (const catWord of catWords) { if (findBestMatchForWord(catWord, ocrWords) < WORD_SIMILARITY_THRESHOLD) { allWordsFound = false; break; } }
                        if (allWordsFound) { setField(docForm['doc-category'], category); break; }
                    }
                }
                if (!docForm['doc-subcategory'].value) {
                    for (const subcategory of sortedSubcategories) {
                        const subCatWords = subcategory.toLowerCase().split(' '); let allWordsFound = true;
                        for (const subCatWord of subCatWords) { if (findBestMatchForWord(subCatWord, ocrWords) < WORD_SIMILARITY_THRESHOLD) { allWordsFound = false; break; } }
                        if (allWordsFound) { setField(docForm['doc-subcategory'], subcategory); break; }
                    }
                }
                if (!docForm['doc-category'].value) {
                    const recognizers = [
                        { name: 'Luce', keywords: /enel|servizio elettrico|e-distribuzione|a2a energia/i, cat: 'Bollette', sub: 'Luce' },
                        { name: 'Gas', keywords: /enel energia|eni|plenitude|snam|italgas|a2a/i, cat: 'Bollette', sub: 'Gas' },
                        { name: 'Acqua', keywords: /acea|acquedotto|publiacqua|acque/i, cat: 'Bollette', sub: 'Acqua' },
                        { name: 'Telefonia', keywords: /tim|telecom|vodafone|wind|tre|iliad|fastweb|sky wifi/i, cat: 'Bollette', sub: 'Telefonia' },
                        { name: 'Rifiuti', keywords: /tari|tassa sui rifiuti|azienda municipalizzata/i, cat: 'Tasse', sub: 'Rifiuti' },
                        { name: 'Assicurazione', keywords: /allianz|generali|unipolsai|cattolica assicurazioni|reale mutuale/i, cat: 'Assicurazioni', sub: 'Polizza' },
                        { name: 'Sanità', keywords: /referto|ricetta medica|asl|cup|azienda sanitaria|analisi/i, cat: 'Sanità', sub: 'Referto' },
                        { name: 'Multe', keywords: /multa|sanzione amministrativa|verbale di accertamento|polizia locale/i, cat: 'Multe', sub: 'Violazione' },
                        { name: 'Banca', keywords: /estratto conto|banca|intesa sanpaolo|unicredit|bper/i, cat: 'Banca', sub: 'Estratto Conto'},
                        { name: 'Fattura', keywords: /fattura|ricevuta fiscale|documento commerciale/i, cat: 'Fatture', sub: 'Generica' }
                    ];
                    for (const rec of recognizers) { if (rec.keywords.test(text)) { setField(docForm['doc-category'], rec.cat); setField(docForm['doc-subcategory'], rec.sub); break; } }
                }
                const oggettoMatch = text.match(/(?:^|\n)\s*oggetto:?\s*(.*)/i);
                if (oggettoMatch && oggettoMatch[1]) appendToDetails('Oggetto', oggettoMatch[1].trim());
                const yearMatch = text.match(/\b(20\d{2})\b/);
                if (yearMatch) setField(docForm['doc-year'], yearMatch[0]);
                const dateMatch = text.match(/\b(\d{1,2}[\s\/\-\.]\d{1,2}[\s\/\-\.]\d{2,4})\b/);
                if(dateMatch) appendToDetails('Data Doc.', dateMatch[0]);
                const scadenzaMatch = text.match(/(?:scadenza|pagare entro il|da versare entro)[\s\S]*?(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/i);
                if (scadenzaMatch && scadenzaMatch[1]) { appendToDetails('Scadenza', scadenzaMatch[1]); addTagFromOCR('Da Pagare'); }
                const importoMatch = text.match(/(?:totale|importo|totale da pagare)[\s\S]*?€?\s*(\d+[,.]\d{2})/i);
                if (importoMatch && importoMatch[1]) appendToDetails('Importo', `€ ${importoMatch[1].replace(',', '.')}`);
                const pivaMatch = text.match(/(?:p\.?\s?iva|partita iva)[\s\S]*?(\d{11})/i);
                if (pivaMatch && pivaMatch[1]) appendToDetails('P.IVA', pivaMatch[1]);
                const cfMatch = text.match(/(?:c\.?\s?f\.?|codice fiscale)[\s\S]*?([A-Z]{6}\d{2}[A-Z]\d{2}[A-Z]\d{3}[A-Z])/i);
                if (cfMatch && cfMatch[1]) appendToDetails('Cod. Fiscale', cfMatch[1]);
                const ibanMatch = text.match(/\b(IT\d{2}[A-Z]\d{22})\b/i);
                if (ibanMatch && ibanMatch[0]) appendToDetails('IBAN', ibanMatch[0]);
                const docNumMatch = text.match(/(?:fattura|documento|polizza|verbale|bolletta|contratto)\s*(?:n\.?|numero|nr\.?)?\s*([a-zA-Z0-9\/\-]+)/i);
                if(docNumMatch && docNumMatch[1]) appendToDetails(`N. ${docNumMatch[0].split(/[\s\n\r]/)[0]}`, docNumMatch[1]);
                if (/quietanza|pagamento ricevuto|pagato|pagata/i.test(text)) { addTagFromOCR('Pagato'); if (currentTagsSet.has('Da Pagare')) { currentTagsSet.delete('Da Pagare'); updateTagsUI(); } }
                if (/multa|sanzione|urgente|sollecito|sinistro/i.test(text)) addTagFromOCR('Urgente');
                if (!detailsFound && text.trim().length > 0 && !docForm['doc-details'].value) {
                    const textSnippet = text.split('\n').slice(0, 5).join('\n').trim();
                    docForm['doc-details'].value = `Testo riconosciuto (estratto):\n----------------------------\n${textSnippet}`;
                    highlightField(docForm['doc-details']);
                }
            }
            
            async function renderPdfToCanvas(canvas, fileData, options = {}) {
                if (!canvas || !fileData) return;
                try {
                    const pdfjsLib = getPdfjsLib();
                    if (!pdfjsLib) throw new Error("PDF.js library not found");
                    const typedarray = new Uint8Array(atob(fileData.split(',')[1]).split('').map(char => char.charCodeAt(0)));
                    const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                    const page = await pdf.getPage(1);
                    let scale = 1.0;
                    const viewport = page.getViewport({ scale: scale });
                    if (options.isThumbnail) scale = 128 / viewport.height;
                    else if (options.isModal) {
                        const container = canvas.parentElement;
                        if (container) scale = Math.min(container.clientWidth / viewport.width, container.clientHeight / viewport.height);
                    } else scale = (canvas.parentElement.clientWidth - 20) / viewport.width;
                    const scaledViewport = page.getViewport({ scale: scale });
                    canvas.height = scaledViewport.height; canvas.width = scaledViewport.width;
                    await page.render({ canvasContext: canvas.getContext('2d'), viewport: scaledViewport }).promise;
                } catch (error) {
                    console.error(`Error rendering PDF preview:`, error);
                    const container = canvas.parentElement;
                    if (container) {
                        container.innerHTML = `<div class="text-center text-red-500 p-4"><i data-lucide="file-warning" class="mx-auto h-16 w-16"></i><p class="mt-2 text-sm">Errore anteprima PDF</p></div>`;
                        lucide.createIcons();
                    }
                }
            }

            function handleFilePreview(event) {
                const file = event.target.files[0];
                const previewContainer = document.getElementById('file-preview-container');
                const previewEl = document.getElementById('file-preview');
                ocrBtn.disabled = !file || (!file.type.startsWith('image/') && file.type !== 'application/pdf');
                if (file) parseFilenameForMetadata(file.name);
                previewContainer.classList.add('hidden');
                previewEl.innerHTML = '';
                if (!file) return;
                previewContainer.classList.remove('hidden');
                const reader = new FileReader();
                reader.onload = e => {
                    const fileType = file.type || getMimeTypeFromName(file.name);
                    if (fileType.startsWith('image/')) previewEl.innerHTML = `<img src="${e.target.result}" class="max-w-full max-h-40 h-auto rounded-md mx-auto">`;
                    else if (fileType === 'application/pdf') {
                        previewEl.innerHTML = `<canvas class="max-w-full h-auto rounded-md mx-auto"></canvas>`;
                        renderPdfToCanvas(previewEl.querySelector('canvas'), e.target.result);
                    } else {
                        previewEl.innerHTML = `<div class="text-center p-4"><i data-lucide="file-text" class="mx-auto h-16 w-16 text-gray-400"></i><p class="mt-2 text-sm text-gray-600 dark:text-gray-300 truncate">${file.name}</p></div>`;
                        lucide.createIcons();
                    }
                };
                reader.readAsDataURL(file);
            }
            
            function renderDocuments() {
                currentPage = 1;
                Crud.getAll(docs => {
                    const searchTerm = searchInput.value.toLowerCase();
                    const filteredDocs = docs.filter(doc => {
                        const inCategoryFilter = (!currentFilter.year || doc.year == currentFilter.year) &&
                                         (!currentFilter.category || doc.category === currentFilter.category) &&
                                         (!currentFilter.subcategory || doc.subcategory === currentFilter.subcategory);
                        const inTagFilter = !activeTagFilter || (doc.tags && doc.tags.includes(activeTagFilter));
                        const inSearch = searchTerm === '' || 
                                         doc.displayName.toLowerCase().includes(searchTerm) ||
                                         doc.category.toLowerCase().includes(searchTerm) ||
                                         doc.subcategory.toLowerCase().includes(searchTerm) ||
                                         (doc.details && doc.details.toLowerCase().includes(searchTerm)) ||
                                         (doc.tags && doc.tags.some(tag => tag.toLowerCase().includes(searchTerm)));
                        return inCategoryFilter && inTagFilter && inSearch;
                    });
                    filteredDocs.sort((a, b) => {
                        switch (sortSelect.value) {
                            case 'name_asc': return a.displayName.localeCompare(b.displayName);
                            case 'name_desc': return b.displayName.localeCompare(a.displayName);
                            case 'year_asc': return a.year - b.year;
                            case 'year_desc': return b.year - a.year;
                            case 'date_asc': return a.uploadDate - b.uploadDate;
                            default: return b.uploadDate - a.uploadDate;
                        }
                    });
                    fullFilteredDocs = filteredDocs;
                    displayCurrentPage();
                });
            }
            
            function displayCurrentPage(append = false) {
                if (!append) docListContainer.innerHTML = '';
                const start = (currentPage - 1) * itemsPerPage;
                const docsToRender = fullFilteredDocs.slice(start, start + itemsPerPage);
                if (fullFilteredDocs.length === 0 && !append) {
                    emptyStateEl.classList.remove('hidden');
                    loadMoreBtn.classList.add('hidden');
                } else {
                    emptyStateEl.classList.add('hidden');
                    if (currentView === 'list') {
                        if(!append) docListContainer.className = 'space-y-3';
                        docsToRender.forEach(createDocCard);
                    } else {
                        if(!append) docListContainer.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4';
                        docsToRender.forEach(createDocGridItem);
                    }
                    loadMoreBtn.classList.toggle('hidden', fullFilteredDocs.length <= start + itemsPerPage);
                }
                lucide.createIcons();
            }

            function createDocCard(doc) {
                const details = document.createElement('details');
                details.className = 'bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden';
                const tagsHTML = doc.tags?.length ? `<strong class="text-gray-500 dark:text-gray-400 col-span-1">Tags:</strong><div class="col-span-3 flex flex-wrap gap-2">${doc.tags.map(tag => `<button class="tag-link bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-xs font-medium px-2.5 py-0.5 rounded-full hover:bg-blue-200 dark:hover:bg-blue-800" data-tag="${tag}">${tag}</button>`).join('')}</div>` : '';
                const detailsHTML = doc.details ? `<strong class="text-gray-500 dark:text-gray-400 col-span-1 mt-2">Dettagli:</strong><p class="col-span-3 text-gray-700 dark:text-gray-300 whitespace-pre-wrap">${doc.details}</p>` : '';
                const attachmentsHTML = doc.attachments?.length ? `<strong class="text-gray-500 dark:text-gray-400 col-span-1 mt-2">Allegati:</strong><div class="col-span-3 space-y-1">${doc.attachments.map((att, index) => `<a href="#" class="attachment-link text-blue-600 dark:text-blue-400 hover:underline text-sm flex items-center gap-1" data-doc-id="${doc.id}" data-attachment-index="${index}"><i data-lucide="paperclip" class="w-3 h-3"></i> ${att.fileName}</a>`).join('')}</div>` : '';
                details.innerHTML = `<summary class="flex justify-between items-center p-4 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700/50"><div><span class="font-semibold">${doc.displayName}</span><div class="text-xs text-gray-500">${doc.category} / ${doc.subcategory}</div></div><div class="flex items-center gap-2"><button class="preview-btn p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-600" data-id="${doc.id}" title="Apri anteprima"><i data-lucide="eye" class="w-5 h-5"></i></button><i data-lucide="chevron-right" class="summary-arrow w-5 h-5"></i></div></summary><div class="details-content max-h-0 bg-gray-50 dark:bg-gray-700/50 p-4 border-t border-gray-200 dark:border-gray-700"><div class="grid grid-cols-4 gap-x-4 gap-y-2 text-sm"><strong class="text-gray-500 dark:text-gray-400">Anno:</strong><span>${doc.year}</span><strong class="text-gray-500 dark:text-gray-400">Caricato:</strong><span>${new Date(doc.uploadDate).toLocaleDateString('it-IT')}</span>${tagsHTML}${detailsHTML}${attachmentsHTML}</div><div class="mt-4 flex justify-end gap-3"><button class="edit-doc-btn text-sm flex items-center gap-1 text-blue-600 dark:text-blue-400 hover:underline" data-id="${doc.id}"><i data-lucide="edit-2" class="w-4 h-4"></i> Modifica</button><button class="delete-doc-btn text-sm flex items-center gap-1 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 hover:underline" data-id="${doc.id}"><i data-lucide="trash-2" class="w-4 h-4"></i> Elimina</button></div></div>`;
                docListContainer.appendChild(details);
            }

            function createDocGridItem(doc) {
                const card = document.createElement('div');
                card.className = 'preview-btn bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-hidden flex flex-col cursor-pointer transition-transform transform hover:scale-105';
                card.dataset.id = doc.id;
                let previewHTML = `<div class="w-full h-32 bg-gray-100 dark:bg-gray-700 flex items-center justify-center"><i data-lucide="file-text" class="w-12 h-12 text-gray-400"></i></div>`;
                if (doc.fileType?.startsWith('image/')) previewHTML = `<div class="w-full h-32 bg-gray-100 dark:bg-gray-700 flex items-center justify-center"><img src="${doc.fileData}" class="w-full h-full object-cover" alt="Anteprima"></div>`;
                else if (doc.fileType === 'application/pdf') {
                    previewHTML = `<div class="w-full h-32 bg-gray-100 dark:bg-gray-700 flex items-center justify-center overflow-hidden"><canvas id="pdf-canvas-${doc.id}" class="max-w-full max-h-full"></canvas></div>`;
                    setTimeout(() => renderPdfToCanvas(document.getElementById(`pdf-canvas-${doc.id}`), doc.fileData, { isThumbnail: true }), 0);
                }
                card.innerHTML = `${previewHTML}<div class="p-3 flex-grow flex flex-col"><h3 class="font-semibold text-sm truncate flex-grow" title="${doc.displayName}">${doc.displayName}</h3><p class="text-xs text-gray-500 truncate">${doc.category} / ${doc.subcategory}</p></div>`;
                docListContainer.appendChild(card);
                if (!doc.fileType || !doc.fileType.startsWith('image/')) lucide.createIcons({nodes: [card]});
            }

            function renderFilterTree() {
                Crud.getAll(docs => {
                    const tree = docs.reduce((acc, doc) => {
                        acc[doc.year] = acc[doc.year] || {};
                        acc[doc.year][doc.category] = acc[doc.year][doc.category] || new Set();
                        if(doc.subcategory) acc[doc.year][doc.category].add(doc.subcategory);
                        return acc;
                    }, {});
                    let html = '';
                    Object.keys(tree).sort((a, b) => b - a).forEach(year => {
                        const isYearActive = currentFilter.year == year && !currentFilter.category, isYearInPath = currentFilter.year == year;
                        html += `<details ${isYearInPath ? 'open' : ''}><summary class="p-1 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 ${isYearActive ? 'active' : ''}" data-filter-type="year" data-filter-value="${year}"><span>${year}</span></summary><ul class="pl-4 ml-1 border-l border-gray-200 dark:border-gray-700">`;
                        Object.keys(tree[year]).sort().forEach(category => {
                            const isCatActive = currentFilter.year == year && currentFilter.category === category && !currentFilter.subcategory, isCatInPath = isYearInPath && currentFilter.category === category;
                            html += `<li><details ${isCatInPath ? 'open' : ''}><summary class="p-1 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 ${isCatActive ? 'active' : ''}" data-filter-type="category" data-filter-value="${category}" data-filter-parent-year="${year}"><span>${category}</span></summary><ul class="pl-4 ml-1 border-l border-gray-200 dark:border-gray-700">${[...tree[year][category]].sort().map(subcategory => `<li class="p-1 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 ${isCatInPath && currentFilter.subcategory === subcategory ? 'active' : ''}" data-filter-type="subcategory" data-filter-value="${subcategory}" data-filter-parent-year="${year}" data-filter-parent-category="${category}"><span>${subcategory}</span></li>`).join('')}</ul></details></li>`;
                        });
                        html += '</ul></details>';
                    });
                    filterTreeEl.innerHTML = html;
                });
            }
            
            function updateDatalists() {
                Crud.getAll(docs => {
                    const categories = new Set(), subcategories = new Set(), allTags = new Set();
                    docs.forEach(doc => {
                        if (doc.category) categories.add(doc.category);
                        if (doc.subcategory) subcategories.add(doc.subcategory);
                        doc.tags?.forEach(tag => allTags.add(tag));
                    });
                    const populate = (datalist, items) => { datalist.innerHTML = [...items].sort().map(item => `<option value="${item}">`).join(''); };
                    populate(categorySuggestions, categories);
                    populate(subcategorySuggestions, subcategories);
                    populate(tagsSuggestions, allTags);
                    allKnownTags = allTags;
                });
            }

            function updateTagsUI() {
                if (!selectedTagsContainer) return;
                docTagsHiddenInput.value = [...currentTagsSet].join(', ');
                while (selectedTagsContainer.firstChild && selectedTagsContainer.firstChild !== docTagsInput) selectedTagsContainer.removeChild(selectedTagsContainer.firstChild);
                currentTagsSet.forEach(tag => {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'flex items-center gap-1 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-sm font-medium pl-2.5 pr-1 py-0.5 rounded-full';
                    tagEl.innerHTML = `${tag}<button type="button" class="remove-tag-btn rounded-full hover:bg-blue-200 dark:hover:bg-blue-700 p-0.5" data-tag="${tag}"><i data-lucide="x" class="w-3 h-3"></i></button>`;
                    selectedTagsContainer.insertBefore(tagEl, docTagsInput);
                });
                availableTagsContainer.innerHTML = '';
                if (categoryScopedTags.size > 0) {
                    const availableTags = [...categoryScopedTags].filter(t => !currentTagsSet.has(t)).sort();
                    if (availableTags.length > 0) {
                        availableTags.forEach(tag => {
                            const tagBtn = document.createElement('button');
                            tagBtn.type = 'button';
                            tagBtn.className = 'add-tag-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 px-2 py-1 rounded-md';
                            tagBtn.textContent = tag;
                            tagBtn.dataset.tag = tag;
                            availableTagsContainer.appendChild(tagBtn);
                        });
                        availableTagsSection.classList.remove('hidden');
                    } else availableTagsSection.classList.add('hidden');
                } else availableTagsSection.classList.add('hidden');
                lucide.createIcons();
            }
            
            async function updateCategoryScopedTags(category) {
                if (!category?.trim()) categoryScopedTags = new Set();
                else {
                    await new Promise(resolve => {
                        Crud.getAll(docs => {
                            const tags = new Set();
                            docs.filter(doc => doc.category === category).forEach(doc => doc.tags?.forEach(tag => tags.add(tag)));
                            categoryScopedTags = tags;
                            resolve();
                        });
                    });
                }
                updateTagsUI();
            }

            function addTag(tag) {
                if (tag.trim()) {
                    currentTagsSet.add(tag.trim());
                    updateTagsUI();
                }
            }
            
            function renderStats() {
                Crud.getAll(docs => {
                    statsTotalDocs.textContent = docs.length;
                    let totalSize = docs.reduce((acc, doc) => acc + (getBase64Size(doc.fileData) || 0) + (doc.attachments || []).reduce((attAcc, att) => attAcc + (getBase64Size(att.fileData) || 0), 0), 0);
                    statsTotalSize.textContent = formatBytes(totalSize);
                });
            }
            
            const renderPreviewContent = async (fileData, fileType, fileName) => {
                previewContent.innerHTML = `<div class="text-white"><div class="ocr-loader mx-auto"></div><p class="mt-2">Caricamento anteprima...</p></div>`;
                try {
                    if (fileType.startsWith('image/')) {
                        const img = document.createElement('img');
                        img.src = fileData;
                        img.className = 'max-w-full max-h-full object-contain';
                        previewContent.innerHTML = ''; previewContent.appendChild(img);
                    } else if (fileType === 'application/pdf') {
                        const canvas = document.createElement('canvas');
                        canvas.className = 'max-w-full max-h-full object-contain bg-white rounded-md shadow-lg';
                        previewContent.innerHTML = ''; previewContent.appendChild(canvas);
                        await renderPdfToCanvas(canvas, fileData, { isModal: true });
                    } else if (fileType.endsWith('.document') || fileName.endsWith('.docx')) {
                        const docContainer = document.createElement('div');
                        docContainer.className = "bg-white p-8 rounded-md w-full h-full overflow-y-auto text-black";
                        previewContent.innerHTML = ''; previewContent.appendChild(docContainer);
                        await window.docx.renderAsync(dataURLtoBlob(fileData), docContainer);
                    } else if (fileType.endsWith('.sheet') || fileName.endsWith('.xlsx')) {
                        const excelContainer = document.createElement('div');
                        excelContainer.className = 'excel-preview-container';
                        previewContent.innerHTML = ''; previewContent.appendChild(excelContainer);
                        const arrayBuffer = await dataURLtoBlob(fileData).arrayBuffer();
                        const workbook = XLSX.read(new Uint8Array(arrayBuffer), {type:"array"});
                        excelContainer.innerHTML = XLSX.utils.sheet_to_html(workbook.Sheets[workbook.SheetNames[0]]);
                    } else throw new Error("Anteprima non disponibile");
                } catch (error) {
                    console.error("Errore anteprima:", error);
                    previewContent.innerHTML = `<div class="text-center text-white p-8"><i data-lucide="file-warning" class="mx-auto h-32 w-32 text-yellow-400"></i><p class="mt-4">Anteprima non disponibile per ${fileName}</p><p class="text-xs text-gray-400 mt-1">${error.message}</p></div>`;
                    lucide.createIcons();
                }
            };

            function showPreviewModal(docId, attachmentIndex = -1) {
                Crud.get(docId, doc => {
                    if(!doc) return;
                    currentPreviewDoc = doc;
                    previewTitle.textContent = doc.displayName;
                    const fileToShow = (attachmentIndex > -1 && doc.attachments?.[attachmentIndex])
                        ? { data: doc.attachments[attachmentIndex].fileData, type: doc.attachments[attachmentIndex].fileType, name: doc.attachments[attachmentIndex].fileName }
                        : { data: doc.fileData, type: doc.fileType, name: doc.fileName };
                    renderPreviewContent(fileToShow.data, fileToShow.type, fileToShow.name);
                    if (doc.attachments?.length > 0) {
                        previewAttachmentsBar.innerHTML = `<button class="attachment-preview-btn inline-block p-2 rounded-md hover:bg-gray-600 ${attachmentIndex === -1 ? 'bg-blue-600' : ''}" data-index="-1">${doc.fileName} (Principale)</button>` + doc.attachments.map((att, index) => `<button class="attachment-preview-btn inline-block p-2 rounded-md hover:bg-gray-600 ${attachmentIndex === index ? 'bg-blue-600' : ''}" data-index="${index}">${att.fileName}</button>`).join('');
                        previewAttachmentsBar.classList.remove('hidden');
                    } else previewAttachmentsBar.classList.add('hidden');
                    openModal(previewModal);
                });
            }
            
            const openAddModal = () => {
                editingDocId = null;
                docForm.reset();
                clearAllHighlights();
                attachmentsToAdd = [];
                attachmentsListEl.innerHTML = '';
                currentFileNameEl.textContent = '';
                fileInput.setAttribute('required', 'true');
                modalTitle.textContent = "Aggiungi Documento";
                ocrBtn.disabled = true;
                ocrStatusEl.innerHTML = '';
                currentTagsSet = new Set();
                updateCategoryScopedTags('');
                openModal(docModal);
            }

            const openEditModal = (docId) => {
                Crud.get(docId, doc => {
                    if (!doc) return;
                    editingDocId = doc.id;
                    docForm.reset();
                    clearAllHighlights();
                    attachmentsToAdd = [];
                    modalTitle.textContent = "Modifica Documento";
                    docIdInput.value = doc.id;
                    docForm['doc-name'].value = doc.displayName;
                    docForm['doc-year'].value = doc.year;
                    docForm['doc-category'].value = doc.category;
                    docForm['doc-subcategory'].value = doc.subcategory;
                    docForm['doc-details'].value = doc.details || '';
                    currentTagsSet = new Set(doc.tags || []);
                    updateCategoryScopedTags(doc.category);
                    currentFileNameEl.textContent = `File attuale: ${doc.fileName}. Selezionane uno nuovo per sostituirlo.`;
                    fileInput.removeAttribute('required');
                    ocrBtn.disabled = true;
                    ocrStatusEl.innerHTML = '';
                    attachmentsListEl.innerHTML = (doc.attachments || []).map((att, index) => `<div class="flex justify-between items-center bg-gray-100 dark:bg-gray-700 p-1 rounded"><span>${att.fileName}</span><button type="button" class="remove-attachment-btn text-red-500 p-1" data-index="${index}"><i data-lucide="x" class="w-4 h-4"></i></button></div>`).join('');
                    lucide.createIcons();
                    openModal(docModal);
                });
            };

            function showSnackbar(message, isError = false) {
                const el = document.getElementById('snackbar');
                el.textContent = message;
                el.style.backgroundColor = isError ? '#ef4444' : ''; 
                el.style.opacity = '1';
                setTimeout(() => { el.style.opacity = '0'; }, 3000);
            }
            
            const openModal = (modalEl) => modalEl.classList.remove('hidden');
            const closeModal = (modalEl) => {
                modalEl.classList.add('hidden');
                if (modalEl === docModal) handleFilePreview({ target: { files: [] } });
            };

            function updateViewButtons(view) {
                viewListBtn.classList.toggle('text-blue-500', view === 'list');
                viewListBtn.classList.toggle('bg-blue-50', view === 'list');
                viewListBtn.classList.toggle('dark:bg-gray-700', view === 'list');
                viewGridBtn.classList.toggle('text-blue-500', view === 'grid');
                viewGridBtn.classList.toggle('bg-blue-50', view === 'grid');
                viewGridBtn.classList.toggle('dark:bg-gray-700', view === 'grid');
            }

            function setView(view) {
                currentView = view;
                localStorage.setItem('doc-view', view);
                updateViewButtons(view);
                renderDocuments();
            }

            const applyTheme = (theme) => document.documentElement.classList.toggle('dark', theme === 'dark');
            themeToggleBtn.addEventListener('click', () => {
                const newTheme = document.documentElement.classList.contains('dark') ? 'light' : 'dark';
                localStorage.setItem('theme', newTheme);
                applyTheme(newTheme);
            });

            const closeSidebar = () => {
                sidebar.classList.add('-translate-x-full');
                overlay.classList.add('hidden');
            };
            menuBtn.addEventListener('click', () => {
                sidebar.classList.remove('-translate-x-full');
                overlay.classList.remove('hidden');
            });
            overlay.addEventListener('click', closeSidebar);
            closeSidebarBtn.addEventListener('click', closeSidebar);
            resetFilterBtn.addEventListener('click', () => {
                currentFilter = {}; activeTagFilter = null; renderAll();
            });

            filterTreeEl.addEventListener('click', e => {
                const target = e.target.closest('summary, li[data-filter-type="subcategory"]');
                if (!target) return;
                e.preventDefault();
                const { filterType, filterValue, filterParentYear, filterParentCategory } = target.dataset;
                if (filterType === 'subcategory') {
                    currentFilter = { year: filterParentYear, category: filterParentCategory, subcategory: filterValue };
                    closeSidebar();
                } else if (target.tagName === 'SUMMARY') {
                    const isYearActive = currentFilter.year == filterValue && !currentFilter.category;
                    const isCatActive = currentFilter.year == filterParentYear && currentFilter.category === filterValue && !currentFilter.subcategory;
                    if (isYearActive) currentFilter = {};
                    else if (isCatActive) currentFilter = { year: filterParentYear };
                    else {
                        if (filterType === 'year') currentFilter = { year: filterValue };
                        else if (filterType === 'category') currentFilter = { year: filterParentYear, category: filterValue };
                    }
                    if(!target.parentElement.hasAttribute('open')) target.parentElement.setAttribute('open', '');
                }
                renderAll();
            });

            addDocBtn.addEventListener('click', openAddModal);
            cancelBtn.addEventListener('click', () => closeModal(docModal));
            fileInput.addEventListener('change', handleFilePreview);
            ocrBtn.addEventListener('click', runOCR);
            
            attachmentsInput.addEventListener('change', (e) => {
                attachmentsToAdd = [...e.target.files];
                attachmentsListEl.innerHTML += attachmentsToAdd.map(file => `<div class="bg-blue-100 dark:bg-blue-900 p-1 rounded">Nuovo: ${file.name}</div>`).join('');
            });

            attachmentsListEl.addEventListener('click', (e) => {
                if (e.target.closest('.remove-attachment-btn')) {
                    Crud.get(editingDocId, doc => {
                        doc.attachments.splice(parseInt(e.target.closest('.remove-attachment-btn').dataset.index), 1);
                        Crud.save(doc, false).then(() => openEditModal(editingDocId));
                    });
                }
            });

            docForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const saveButton = e.submitter || docForm.querySelector('button[type="submit"]');
                const originalButtonHTML = saveButton.innerHTML;
                saveButton.disabled = true; saveButton.innerHTML = `<div class="ocr-loader mx-auto"></div>`;
                try {
                    let fileHash = null;
                    if (fileInput.files[0]) {
                        fileHash = await calculateFileHash(fileInput.files[0]);
                        const existingDoc = await checkForDuplicate(fileHash);
                        if (existingDoc && (!editingDocId || existingDoc.id != editingDocId)) {
                            throw new Error(`Questo file esiste già: "${existingDoc.displayName}"`);
                        }
                    }
                    const processSubmit = async (baseDoc) => {
                        const newAttachments = await Promise.all(attachmentsToAdd.map(readFileAsDataURL));
                        baseDoc.attachments = [...(baseDoc.attachments || []), ...newAttachments];
                        const docData = { ...baseDoc,
                            displayName: docForm['doc-name'].value, year: parseInt(docForm['doc-year'].value),
                            category: docForm['doc-category'].value, subcategory: docForm['doc-subcategory'].value,
                            tags: docTagsHiddenInput.value.split(',').map(t => t.trim()).filter(Boolean),
                            details: docForm['doc-details'].value,
                            uploadDate: editingDocId ? baseDoc.uploadDate : new Date().getTime(),
                        };
                        if (fileHash) docData.contentHash = fileHash;
                        await Crud.save(docData);
                    };
                    if (editingDocId) {
                        await new Promise((resolve, reject) => Crud.get(editingDocId, async (doc) => {
                            try {
                                if (!doc) return reject(new Error("Doc da modificare non trovato."));
                                let docToProcess = { ...doc };
                                if (fileInput.files[0]) {
                                    const { fileData, fileName, fileType } = await readFileAsDataURL(fileInput.files[0]);
                                    docToProcess = { ...docToProcess, fileData, fileName, fileType };
                                }
                                await processSubmit(docToProcess);
                                resolve();
                            } catch (err) { reject(err); }
                        }));
                    } else {
                        if (!fileInput.files[0]) throw new Error("Seleziona un file principale.");
                        const { fileData, fileName, fileType } = await readFileAsDataURL(fileInput.files[0]);
                        await processSubmit({ fileData, fileName, fileType, attachments: [] });
                    }
                } catch (error) {
                    console.error("Errore salvataggio:", error);
                    showSnackbar(error.message || "Errore nel salvataggio.", true);
                } finally {
                    saveButton.disabled = false; saveButton.innerHTML = originalButtonHTML;
                }
            });
            
            docListContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.preview-btn, .edit-doc-btn, .attachment-link, .tag-link, .delete-doc-btn');
                if (!target) return;
                e.preventDefault();
                const id = target.dataset.id || target.dataset.docId;
                if (target.matches('.delete-doc-btn')) { docIdToDelete = parseInt(id); openModal(confirmDeleteModal); }
                else if (target.matches('.tag-link')) { activeTagFilter = target.dataset.tag; renderAll(); }
                else if (target.matches('.attachment-link')) showPreviewModal(id, parseInt(target.dataset.attachment-index));
                else if (target.matches('.edit-doc-btn')) openEditModal(id);
                else if (target.matches('.preview-btn')) showPreviewModal(id);
            });

            docTagsInput.addEventListener('keydown', e => {
                if (e.key === ',' || e.key === 'Enter') {
                    e.preventDefault();
                    addTag(docTagsInput.value);
                    docTagsInput.value = '';
                }
            });

            // CORREZIONE: Aggiunto evento 'blur' per migliorare l'usabilità su mobile
            docTagsInput.addEventListener('blur', () => {
                if (docTagsInput.value.trim()) {
                    addTag(docTagsInput.value);
                    docTagsInput.value = '';
                }
            });

            selectedTagsContainer.addEventListener('click', e => {
                const removeBtn = e.target.closest('.remove-tag-btn');
                if (removeBtn) {
                    currentTagsSet.delete(removeBtn.dataset.tag);
                    updateTagsUI();
                } else {
                    docTagsInput.focus();
                }
            });

            availableTagsContainer.addEventListener('click', e => {
                if (e.target.closest('.add-tag-btn')) {
                    addTag(e.target.dataset.tag);
                }
            });
            categoryInput.addEventListener('input', (e) => updateCategoryScopedTags(e.target.value));

            closePreviewBtn.addEventListener('click', () => closeModal(previewModal));
            
            printBtn.addEventListener('click', () => {
                const contentEl = previewContent.querySelector('canvas, img, div.docx-wrapper, div.excel-preview-container');
                if (contentEl) {
                    const printWindow = window.open('', '_blank');
                    if(contentEl.matches('canvas, img')) {
                        const dataUrl = contentEl.tagName === 'CANVAS' ? contentEl.toDataURL('image/png') : contentEl.src;
                        printWindow.document.write(`<html><body style="text-align:center;"><img src="${dataUrl}" style="max-width:100%;" onload="window.print();window.close();"></body></html>`);
                    } else {
                        printWindow.document.write('<html><head><title>Stampa Documento</title></head><body>' + contentEl.innerHTML + '</body></html>');
                    }
                    printWindow.document.close(); printWindow.focus();
                } else showSnackbar("Stampa non disponibile per questo file.", true);
            });

            editPreviewBtn.addEventListener('click', () => { if (currentPreviewDoc) { closeModal(previewModal); openEditModal(currentPreviewDoc.id); } });
            deletePreviewBtn.addEventListener('click', () => { if (currentPreviewDoc) { docIdToDelete = currentPreviewDoc.id; openModal(confirmDeleteModal); } });
            downloadBtn.addEventListener('click', () => {
                if(currentPreviewDoc){
                    const a = document.createElement('a');
                    const idx = parseInt(previewAttachmentsBar.querySelector('.bg-blue-600')?.dataset.index ?? -1);
                    const file = (idx === -1) 
                        ? { data: currentPreviewDoc.fileData, name: currentPreviewDoc.fileName }
                        : { data: currentPreviewDoc.attachments[idx].fileData, name: currentPreviewDoc.attachments[idx].fileName };
                    a.href = file.data; a.download = file.name; a.click();
                }
            });
            previewAttachmentsBar.addEventListener('click', (e) => { if (e.target.closest('.attachment-preview-btn')) showPreviewModal(currentPreviewDoc.id, parseInt(e.target.dataset.index)); });
            
            cancelDeleteBtn.addEventListener('click', () => { docIdToDelete = null; closeModal(confirmDeleteModal); });
            confirmDeleteBtn.addEventListener('click', () => { if (docIdToDelete) { Crud.delete(docIdToDelete); docIdToDelete = null; closeModal(confirmDeleteModal); } });

            exportBtn.addEventListener('click', () => {
                Crud.getAll(async (docs) => {
                    if (docs.length === 0) return showSnackbar("Nessun documento da esportare.");
                    showSnackbar("Creazione del backup in corso...");
                    try {
                        const zip = new JSZip(); const metadata = [];
                        for (const doc of docs) {
                            const docMetadata = { ...doc };
                            const mainFileName = `${doc.id}-${doc.fileName.replace(/[^a-zA-Z0-9.\-_]/g, '_')}`;
                            docMetadata.filePath = `files/${mainFileName}`;
                            zip.file(docMetadata.filePath, dataURLtoBlob(doc.fileData)); delete docMetadata.fileData;
                            if (doc.attachments?.length) {
                                docMetadata.attachments = doc.attachments.map((att, i) => {
                                    const attMetadata = { ...att };
                                    const attFileName = `${doc.id}-att-${i}-${att.fileName.replace(/[^a-zA-Z0-9.\-_]/g, '_')}`;
                                    attMetadata.filePath = `files/${attFileName}`;
                                    zip.file(attMetadata.filePath, dataURLtoBlob(att.fileData)); delete attMetadata.fileData;
                                    return attMetadata;
                                });
                            }
                            metadata.push(docMetadata);
                        }
                        zip.file("metadata.json", JSON.stringify(metadata, null, 2));
                        const zipBlob = await zip.generateAsync({ type: "blob" });
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(zipBlob); a.download = 'backup_documenti.zip'; a.click();
                        URL.revokeObjectURL(a.href); showSnackbar("Esportazione completata.");
                    } catch (err) { showSnackbar("Errore durante l'esportazione.", true); console.error(err); }
                });
            });

            importBtn.addEventListener('click', () => importFileInput.click());
            
            // =====================================================================
            // BLOCCO DI IMPORTAZIONE CORRETTO E ROBUSTO
            // =====================================================================
            importFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                // Mostra la modal di caricamento
                importProgressText.textContent = "Preparazione dell'archivio...";
                importProgressBar.style.width = '0%';
                importProgressPercentage.textContent = '0%';
                openModal(importLoadingModal);

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const zip = await JSZip.loadAsync(e.target.result);
                        const metadataFile = zip.file("metadata.json");
                        if (!metadataFile) throw new Error("File metadata.json non trovato.");

                        importProgressText.textContent = "Lettura metadati...";
                        importProgressBar.style.width = '5%';
                        importProgressPercentage.textContent = '5%';

                        const metadata = JSON.parse(await metadataFile.async("string"));
                        const totalDocs = metadata.length;
                        showSnackbar(`Inizio importazione di ${totalDocs} documenti...`);

                        // 1. Pulisce il DB in una transazione separata e attende il completamento
                        await new Promise((resolve, reject) => {
                            const tx = db.transaction("documents", "readwrite");
                            tx.oncomplete = () => resolve();
                            tx.onerror = (event) => reject(event.target.error);
                            tx.objectStore("documents").clear();
                        });

                        // 2. Itera su ogni documento e lo salva in una nuova transazione
                        for (let i = 0; i < totalDocs; i++) {
                            const docMeta = metadata[i];
                            const progress = ((i + 1) / totalDocs) * 90 + 5; // Avanzamento da 5% a 95%

                            importProgressText.textContent = `Importazione: ${docMeta.displayName || docMeta.fileName} (${i + 1}/${totalDocs})`;
                            importProgressBar.style.width = `${progress}%`;
                            importProgressPercentage.textContent = `${Math.round(progress)}%`;

                            // Processa file principale e allegati
                            if (zip.file(docMeta.filePath)) {
                                const mainFileBlob = await zip.file(docMeta.filePath).async("blob");
                                docMeta.fileData = (await readFileAsDataURL(mainFileBlob)).fileData;
                                docMeta.fileType = mainFileBlob.type || getMimeTypeFromName(docMeta.fileName);
                                docMeta.contentHash = await calculateFileHash(new File([mainFileBlob], docMeta.fileName, { type: docMeta.fileType }));
                            }
                            delete docMeta.filePath;

                            if (docMeta.attachments) {
                                for(let attMeta of docMeta.attachments) {
                                    if (zip.file(attMeta.filePath)) {
                                        const attFileBlob = await zip.file(attMeta.filePath).async("blob");
                                        attMeta.fileData = (await readFileAsDataURL(attFileBlob)).fileData;
                                        attMeta.fileType = attFileBlob.type || getMimeTypeFromName(attMeta.fileName);
                                    }
                                    delete attMeta.filePath;
                                }
                            }
                            delete docMeta.id;
                            
                            // Salva il documento in una transazione dedicata
                            await Crud.save(docMeta, false);

                            // Piccola pausa per permettere all'interfaccia di aggiornarsi
                            if (i % 10 === 0) {
                                await new Promise(res => setTimeout(res, 1));
                            }
                        }
                        
                        importProgressText.textContent = "Finalizzazione...";
                        importProgressBar.style.width = '100%';
                        importProgressPercentage.textContent = '100%';

                        setTimeout(() => {
                            closeModal(importLoadingModal);
                            showSnackbar('Importazione completata!');
                            renderAll();
                        }, 500);

                    } catch (error) {
                        closeModal(importLoadingModal);
                        showSnackbar(`Errore durante l'importazione: ${error.message}`, true);
                        console.error("Import error:", error);
                        // Ricarica i dati esistenti in caso di fallimento
                        renderAll();
                    } finally {
                        importFileInput.value = '';
                    }
                };
                reader.readAsArrayBuffer(file);
            });

            searchInput.addEventListener('input', renderDocuments);
            sortSelect.addEventListener('change', renderDocuments);
            itemsPerPageSelect.addEventListener('change', (e) => { itemsPerPage = parseInt(e.target.value, 10); renderDocuments(); });
            loadMoreBtn.addEventListener('click', () => { currentPage++; displayCurrentPage(true); });
            viewListBtn.addEventListener('click', () => setView('list'));
            viewGridBtn.addEventListener('click', () => setView('grid'));
            fieldsToHighlight.forEach(field => {
                const removeHighlight = () => field.classList.remove('highlight-suggestion');
                field.addEventListener('input', removeHighlight);
                field.addEventListener('focus', removeHighlight);
            });
            
            fullscreenBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(err => console.error(err));
                else if (document.exitFullscreen) document.exitFullscreen();
            });
            document.addEventListener('fullscreenchange', () => {
                const isFullscreen = !!document.fullscreenElement;
                fullscreenBtn.querySelector('[data-lucide="maximize"]').classList.toggle('hidden', isFullscreen);
                fullscreenBtn.querySelector('[data-lucide="minimize"]').classList.toggle('hidden', !isFullscreen);
            });

            // --- Inizializzazione ---
            const savedTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            applyTheme(savedTheme);
            updateViewButtons(currentView);
            initDB();
            lucide.createIcons();
        }

        // --- Avvio dell'applicazione ---
        window.addEventListener('load', () => {
            const requiredLibs = ['pdfjsLib', 'Tesseract', 'JSZip', 'lucide', 'docx', 'XLSX'];
            let retries = 0;
            const checkInterval = setInterval(() => {
                const missingLibs = requiredLibs.filter(lib => typeof window[lib] === 'undefined');
                if (missingLibs.length === 0) {
                    clearInterval(checkInterval);
                    initializeApp(); // Avvia l'app solo quando le librerie sono pronte
                } else if (++retries > 20) {
                    clearInterval(checkInterval);
                    document.getElementById('missing-libs-list').textContent = `Dettagli: ${missingLibs.join(', ')} non trovate.`;
                    document.getElementById('load-error-modal').classList.remove('hidden');
                    if (window.lucide) lucide.createIcons();
                    document.getElementById('reload-page-btn').onclick = () => window.location.reload();
                }
            }, 500);
        });
    </script>
</body>
</html>
